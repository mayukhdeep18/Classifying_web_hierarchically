jaguar : fast network communication and i/o in java j ava a ccess to g eneric u nderlying a rchitectural r esources matt welsh last updated 17 may 2000 introduction jaguar is an extension of the java runtime environment which enables direct java access to operating system and hardware resources , such as fast network interfaces , memory-mapped and programmed i/o , and specialized machine instruction sets. jaguar can be thought of as a replacement for the java native interface. unlike the jni , however , jaguar does not require copying of data between the jvm and c code , nor expensive traversals between the java and native code contexts. rather , jaguar relies upon a flexible bytecode translation technique which directly inlines specialized " driver " code to access low-level system resources from java while maintaining type safety. this translation can be performed by a jit compiler , a static ( " ahead of time " ) compiler , or by a front-end which translates java bytecode to machine-independent " jaguar bytecode " . we have implemented a jaguar interface to berkeley linux via communication architecture , which is implemented over the myrinet system-area network. this system , jaguarvia , provides direct , zero-copy java access to the myrinet with a round-trip time of 73 microseconds for small messages , and a peak bandwidth of over 488 mbits/second. this is nearly identical ( within 1 % ) to the performance of berkeley linux via as accessed from c code . another use of jaguar is pre-serialized objects , a mechanism which greatly reduces the cost of java object serialization. this is accomplished by rewriting java object field accesses to store data in memory in a " pre-serialized " form , ready for communication or i/o . our analysis shows that using pre-serialized objects can save a factor of 80 in performance over standard java serialization for communicating over jaguarvia . on top of jaguar , we have implemented tigris , a cluster-based i/o system and programming model which allows resources to be automatically balanced across the cluster ; this is a java reimplementation of the river system. tigris shields applications from asymmetries in cpu , i/o , and networking performance , through the use of a dataflow programming model and a distributed queue which allows data to adaptively flow from producers to consumers. by using jaguar for communication and i/o , tigris is able to obtain performance rivaling that of similar systems implemented in c + + . jaguar is being used by the uc berkeley ninja and telegraph projects to build high-performance , scalable systems in java . news may 17 , 2000 : jaguar v2.1 has been released ! here is the release documentation . download instructions . this release is targeted at x86 linux systems , however , it should be possible to compile and use it on other platforms. this software is entirely open source ; see the release docs for system requirements and copyright information . new in jaguar v2.1 : jaguar support has been added to openjit , an open source jit compiler which is itself implemented in java. the use of openjit allows java applications running on standard jvms to make use of jaguar . jaguar 2 is a reimplementation of the ideas in the original jaguar ( which is described in the papers below ) . rather than requiring that jaguar primitives be implemented as machine code segments within a jit compiler , jaguar 2 relies on a " front-end " compiler to translate standard java bytecode into specialized jaguar bytecode . jaguar bytecode is identical to java bytecode except that ( a ) it has the jaguar code transformations applied to it , and ( b ) it may make use of extra bytecode instructions which are necessary for direct memory access and other low-level system operations . the advantage of this approach is that the jaguar drivers themselves are expressed in a machine-independent and type-safe form ; only the extra jaguar instructions are special. however , even these instructions are typed and can be verified for type-safety . note that only " jaguar driver " code , expressed as bytecode translation rules , may make use of these special instructions. that is , the java application can not directly use these instructions ; rather , the jaguar driver code is inlined into the application at compile time , through a set of bytecode translation rules. there are three advantages to this approach : the resulting code is very efficient ; the jaguar driver code is inlined into the application and can be optimized along with it. the overhead of the native method interface is entirely avoided . applications can express low-level system operations naturally , through method calls , field accesses , and use of operators ; native methods , on the other hand , must always be hidden behind a method-call interface . protection relies upon the safety of the jaguar driver translation rules -- not the application -- and these translation rules can themselves be type-checked . another advantage is that jaguar 2 is no longer so tightly bound to a particular jit/jvm implementation. given the source code to your favorite jit or other java compiler , adding jaguar bytecode support to it is easy. the jaguar 2 front-end compiler is itself written in java and is highly portable. two back-end compilers are available : a jit compiler ( based on openjit ) and a static java compiler ( based on gcj ) . software release jaguar v2.1 , released 17 may 2000 . here is the release documentation . download instructions . this release is targeted at x86 linux systems , however , it should be possible to compile and use it on other platforms. this software is entirely open source ; see the release docs for system requirements and copyright information . papers safe and efficient hardware specialization of java applications , matt welsh. uc berkeley technical report , may , 2000 . this paper describes the use of jaguar bytecode in jaguar v2.1 , as well as the two latest implementations ( based on gcj and openjit ) . ( pdf ) jaguar : enabling efficient communication and i/o in java , matt welsh and david culler. concurrency : practice and experience , vol. 12 , pp. 519-538 , special issue on java for high-performance applications , december , 1999 . this paper is the best overall discussion of jaguar . ( pdf ) or ( gzipped postscript ) achieving robust , scalable cluster i/o in java , matt welsh and david culler . in proceedings of the fifth acm sigplan workshop on languages , compilers , and runtime environments for scalable computers ( lcr2k ) , rochester , ny , june , 2000 . this paper covers the tigris i/o system built on top of jaguar . ( pdf ) a system supporting high-performance communication and i/o in java , matt welsh. master 's thesis , university of california , berkeley , october , 1999. this is a slightly expanded version of the jaguar and tigris papers . ( pdf ) or ( gzipped postscript ) presentations jaguar : bridging the java server performance gap , matt welsh . presented at sun microsystems laboratories , mountain view , california , march 9 , 2000 . this is the most recent , and best , talk to read. covers the design of jaguar 2.0 . ( html ) jaguar : bridging the java server performance gap , matt welsh . presented at fujitsu laboratories , kawasaki , japan , june 21 , 1999 . somewhat out of date , only covers jaguar 1.0 . ( html ) using java to make servers scream , matt welsh . presented at the acm javagrande'99 conference , san francisco , california , june 12 , 1999 . this is the first talk on jaguar and covers some topics not found in the other talks . ( html ) related projects uc berkeley ninja project -- delivering scalable internet services to arbitrarily small devices uc berkeley telegraph project -- a novel universal database system openjit -- a reflective jit compiler framework implemented in java jalapeno -- a java virtual machine written in java java grande forum -- promoting java for high-performance computing gcj -- high-performance javva compiler based on gcc
