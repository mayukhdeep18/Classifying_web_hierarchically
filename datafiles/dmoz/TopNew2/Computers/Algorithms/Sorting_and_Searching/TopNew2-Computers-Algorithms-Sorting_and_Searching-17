mark nelson programming , mostly . home about mark nelson archives liberal code use policy fast string searching with suffix trees « a floating point problem data compression with the burrows-wheeler transform » posted in august 1st , 1996 by mark nelson in computer science , data compression , magazine articles addthis button begin published in dr. dobb 's journal august , 1996 i think that i shall never see a poem lovely as a tree . poems are made by fools like me , but only god can make a tree . - joyce kilmer a tree 's a tree. how many more do you need to look at ? - ronald reagan the problem matching string sequences is a problem that computer programmers face on a regular basis. some programming tasks , such as data compression or dna sequencing , can benefit enormously from improvements in string matching algorithms. this article discusses a relatively unknown data structure , the suffix tree , and shows how its characteristics can be used to attack difficult string matching problems . imagine that you 've just been hired as a programmer working on a dna sequencing project. researchers are busy slicing and dicing viral genetic material , producing fragmented sequences of nucleotides. they send these sequences to your server , which is then expected to locate the sequences in a database of genomes. the genome for a given virus can have hundreds of thousands of nucleotide bases , and you have hundreds of viruses in your database. you are expected to implement this as a client/server project that gives real-time feedback to the impatient phd.s. what 's the best way to go about it ? it is obvious at this point that a brute force string search is going to be terribly inefficient. this type of search would require you to perform a string comparison at every single nucleotide in every genome in your database. testing a long fragment that has a high hit rate of partial matches would make your client/server system look like an antique batch processing machine. your challenge is to come up with an efficient string matching solution . the intuitive solution since the database that you are testing against is invariant , preprocessing it to simplify the search seems like a good idea. one preprocessing approach is to build a search trie. for searching through input text , a straightforward approach to a search trie yields a thing called a suffix trie . ( the suffix trie is just one step away from my final destination , the suffix tree . ) a trie is a type of tree that has n possible branches from each node , where n is the number of characters in the alphabet. the word 'suffix ' is used in this case to refer to the fact that the trie contains all of the suffixes of a given block of text ( perhaps a viral genome. ) figure 1 the suffix trie representing " bananas " figure 1 shows a suffix trie for the word bananas. there are two important facts to note about this trie. first , starting at the root node , each of the suffixes of bananas is found in the trie , starting with bananas , ananas , nanas , and finishing up with a solitary s. second , because of this organization , you can search for any substring of the word by starting at the root and following matches down the tree until exhausted . the second point is what makes the suffix trie such a nice construct. if you have a input text of length n , and a search string of length m , a traiditonal brute force search will take as many as n * m character comparison to complete. optimized searching techniques , such as the boyer-moore algorithm can guarantee searches that require no more than m + n comparisons , with even better average performance. but the suffix trie demolishes this performance by requiring just m character comparisons , regardless of the length of the text being searched ! remarkable as this might seem , it means i could determine if the word bananas was in the collected works of william shakespeare by performing just seven character comparisons. of course , there is just one little catch : the time needed to construct the trie . the reason you do n't hear much about the use of suffix tries is the simple fact that constructing one requires o ( n 2 ) time and space. this quadratic performance rules out the use of suffix tries where they are needed most : to search through long blocks of data . under the spreading suffix tree a reasonable way past this dilemma was proposed by edward mccreight in 1976 , when he published his paper on what came to be known as the suffix tree . the suffix tree for a given block of data retains the same topology as the suffix trie , but it eliminates nodes that have only a single descendant. this process , known as path compression , means that individual edges in the tree now may represent sequences of text instead of single characters . figure 2 the suffix trie representing " bananas " figure 2 shows what the suffix trie from figure 1 looks like when converted to a suffix tree. you can see that the tree still has the same general shape , just far fewer nodes. by eliminating every node with just a single descendant , the count is reduced from 23 to 11 . in fact , the reduction in the number of nodes is such that the time and space requirements for constructing a suffix tree are reduced from o ( n 2 ) to o ( n ) . in the worst case , a suffix tree can be built with a maximum of 2n nodes , where n is the length of the input text. so for a one-time investment proportional to the length of the input text , we can create a tree that turbocharges our string searches . even you can make a tree mccreight 's original algorithm for constructing a suffix tree had a few disadvantages. principle among them was the requirement that the tree be built in reverse order , meaning characters were added from the end of the input. this ruled the algorithm out for on line processing , making it much more difficult to use for applications such as data compression . twenty years later , esko ukkonen from the university of helsinki came to the rescue with a slightly modified version of the algorithm that works from left to right. both my sample code and the descriptions that follow are based on ukkonen 's work , published in the september 1995 issue of algorithmica . for a given string of text , t , ukkonen 's algorithm starts with an empty tree , then progressively adds each of the n prefixes of t to the suffix tree. for example , when creating the suffix tree for bananas , b is inserted into the tree , then ba , then ban , and so on. when bananas is finally inserted , the tree is complete . figure 3 progressively building the suffix tree suffix tree mechanics adding a new prefix to the tree is done by walking through the tree and visiting each of the suffixes of the current tree. we start at the longest suffix ( ban in figure 3 ) , and work our way down to the shortest suffix , which is the empty string. each suffix ends at a node that consists of one of these three types : a leaf node. in figure 4 , the nodes labeled 1,2 , 4 , and 5 are leaf nodes . an explicit node. the non-leaf nodes that are labeled 0 and 3 in figure 4 are explicit nodes. they represent a point on the tree where two or more edges part ways . an implicit node. in figure 4 , prefixes such as bo , boo , and oo all end in the middle of an edge. these positions are referred to as implicit nodes. they would represent nodes in the suffix trie , but path compression eliminated them. as the tree is built , implicit nodes are sometimes converted to explicit nodes . figure 4 bookkeeper after adding book in figure 4 , there are five suffixes in the tree ( including the empty string ) after adding book to the structure. adding the next prefix , bookk to the tree means visiting each of the suffixes in the existing tree , and adding letter k to the end of the suffix . the first four suffixes , book , ook , ok , and k , all end at leaf nodes. because of the path compression applied to suffix trees , adding a new character to a leaf node will always just add to the string on that node. it will never create a new node , regardless of the letter being added . after all of the leaf nodes have been updated , we still need to add character 'k ' to the empty string , which is found at node 0. since there is already an edge leaving node 0 that starts with letter k , we do n't have to do anything. the newly added suffix k will be found at node 0 , and will end at the implicit node found one character down along the edge leading to node 2 . the final shape of the resulting tree is shown in figure 5 . figure 5 the same tree after adding bookk things get knotty updating the tree in figure 4 was relatively easy. we performed two types of updates : the first was simply the extension of an edge , and the second was an implicit update , which involved no work at all. adding bookke to the tree shown in figure 5 will demonstrate the two other types of updates. in the first type , a new node is created to split an existing edge at an implicit node , followed by the addition of a new edge. the second type of update consists of adding a new edge to an explicit node . figure 6 the split and add update when adding bookke to the tree in figure 5 , we once again start with the longest suffix , bookk , and work our way to the shortest , the empty string. updating the longer suffixes is trivial as long as we are updating leaf nodes. in figure 5 , the suffixes that end in leaf nodes are bookk , ookk , okk , and kk. the first tree in figure 6 shows what the tree looks like after these suffixes have been updated using the simple string extension . the first suffix in figure 5 that does n't terminate at a leaf node is k. when updating a suffix tree , the first non-leaf node is defined as the active point of the tree. all of the suffixes that are longer than the suffix defined by the active point will end in leaf nodes. none of the suffixes after this point will terminate in leaf nodes . the suffix k terminates in an implicit node part way down the edge defined by kke. when testing non-leaf nodes , we need to see if they have any descendants that match the new character being appended. in this case , that would be e . a quick look at the first k in kke shows that it only has a single descendant : k. so this means we have to add a descendent to represent letter e. this is a two step process. first , we split the edge holding the arc so that it has an explicit node at the end of the suffix being tested. the middle tree in figure 6 shows what the tree looks like after the split . once the edge has been split , and the new node has been added , you have a tree that looks like that in the third position of figure 6. note that the k node , which has now grown to be ke , has become a leaf node . updating an explicit node after updating suffix k , we still have to update the next shorter suffix , which is the empty string. the empty string ends at explicit node 0 , so we just have to check to see if it has a descendant that starts with letter e. a quick look at the tree in figure 6 shows that node 0 does n't have a descendant , so another leaf node is added , which yields the tree shown in figure 7 . figure 7 generalizing the algorithm by taking advantage of a few of the characteristics of the suffix tree , we can generate a fairly efficient algorithm. the first important trait is this : once a leaf node , always a leaf node. any node that we create as a leaf will never be given a descendant , it will only be extended through character concatenation. more importantly , every time we add a new suffix to the tree , we are going to automatically extend the edges leading into every leaf node by a single character. that character will be the last character in the new suffix . this makes management of the edges leading into leaf nodes easy. any time we create a new leaf node , we automatically set its edge to represent all the characters from its starting point to the end of the input text. even if we do n't know what those characters are , we know they will be added to the tree eventually. because of this , once a leaf node is created , we can just forget about it ! if the edge is split , its starting point may change , but it will still extend all the way to the end of the input text . this means that we only have to worry about updating explicit and implicit nodes at the active point , which was the first non-leaf node. given this , we would have to progress from the active point to the empty string , testing each node for update eligibility . however , we can save some time by stopping our update earlier. as we walk through the suffixes , we will add a new edge to each node that does n't have a descendant edge starting with the correct character. when we finally do reach a node that has the correct character as a descendant , we can simply stop updating. knowing how the construction algorithm works , you can see that if you find a certain character as a descendant of a particular suffix , you are bound to also find it as a descendant of every smaller suffix . the point where you find the first matching descendant is called the end point. the end point has an additional feature that makes it particularly useful. since we were adding leaves to every suffix between the active point and the end point , we now know that every suffix longer than the end point is a leaf node. this means the end point will turn into the active point on the next pass over the tree ! by confining our updates to the suffixes between the active point and the end point , we cut way back on the processing required to update the tree. and by keeping track of the end point , we automatically know what the active point will be on the next pass. a first pass at the update algorithm using this information might look something like this ( in c-like pseudo code ) : plain text c : update ( new_suffix ) { current_suffix = active_point test_char = last_char in new_suffix done = false ; while ( ! done ) { if current_suffix ends at an explicit node { if the node has no descendant edge starting with test_char create new leaf edge starting at the explicit node else done = true ; } else { if the implicit node 's next char isn ' t test_char { split the edge at the implicit node create new leaf edge starting at the split in the edge } else done = true ; } if current_suffix is the empty string done = true ; else current_suffix = next_smaller_suffix ( current_suffix ) } active_point = current_suffix } the suffix pointer the pseudo-code algorithm shown above is more or less accurate , but it glosses over one difficulty. as we are navigating through the tree , we move to the next smaller suffix via a call to next_smaller_suffix ( ) . this routine has to find the implicit or explicit node corresponding to a particular suffix . if we do this by simply walking down the tree until we find the correct node , our algorithm is n't going to run in linear time. to get around this , we have to add one additional pointer to the tree : the suffix pointer . the suffix pointer is a pointer found at each internal node. each internal node represents a sequence of characters that start at the root. the suffix pointer points to the node that is the first suffix of that string. so if a particular string contains characters 0 through n of the input text , the suffix pointer for that string will point to the node that is the termination point for the string starting at the root that represents characters 1 through n of the input text . figure 8 shows the suffix tree for the string abababc. the first suffix pointer is found at the node that represents abab. the first suffix of that string would be bab , and that is where the suffix pointer at abab points. likewise , bab has its own suffix pointer , which points to the node for ab . figure 7 the suffix tree for abababc with suffix pointers shown as dashed lines the suffix pointers are built at the same time the update to the tree is taking place. as i move from the active point to the end point , i keep track of the parent node of each of the new leaves i create. each time i create a new edge , i also create a suffix pointer from the parent node of the last leaf edge i created to the current parent edge. ( obviously , i ca n't do this for the first edge created in the update , but i do for all the remaining edges. ) with the suffix pointers in place , navigating from one suffix to the next is simply a matter of following a pointer. this critical addition to the algorithm is what reduces it to an o ( n ) algorithm . tree houses to help illustrate this article , i wrote a short program , stree.cpp , that reads in a string of text from standard input and builds a suffix tree using fully documented c + + . a second version , streed.cpp , has extensive debug output as well. links to both are available at the bottom of this article . understanding stree.cpp is really just a matter of understanding the workings of the data structures that it contains. the most important data structure is the edge object. the class definition for edge is : plain text c + + : class edge { public : int first_char_index ; int last_char_index ; int end_node ; int start_node ; void insert ( ) ; void remove ( ) ; edge ( ) ; edge ( int init_first_char_index , int init_last_char_index , int parent_node ) ; int splitedge ( suffix &s ) ; static edge find ( int node , int c ) ; static int hash ( int node , int c ) ; } ; each time a new edge in the suffix tree is created , a new edge object is created to represent it. the four data members of the object are defined as follows : first_char_index , last_char_index : each of the edges in the tree has a sequence of characters from the input text associated with it. to ensure that the storage size of each edge is identical , we just store two indices into the input text to represent the sequence . start_node : the number of the node that represents the starting node for this edge. node 0 is the root of the tree . end_node : the number of the node that represents the end node for this edge. each time an edge is created , a new end node is created as well. the end node for every edge will not change over the life of the tree , so this can be used as an edge id as well . one of the most frequent tasks performed when building the suffix tree is to search for the edge emanating from a particular node based on the first character in its sequence. on a byte oriented computer , there could be as many as 256 edges originating at a single node. to make the search reasonably quick and easy , i store the edges in a hash table , using a hash key based on their starting node number and the first character of their substring. the insert ( ) and remove ( ) member functions are used to manage the transfer of edges in and out of the hash table . the second important data structure used when building the suffix tree is the suffix object. remember that updating the tree is done by working through all of the suffixes of the string currently stored in the tree , starting with the longest , and ending at the end point. a suffix is simply a sequence of characters that starts at node 0 and ends at some point in the tree . it makes sense that we can then safely represent any suffix by defining just the position in the tree of its last character , since we know the first character starts at node 0 , the root. the suffix object , whose definition is shown here , defines a given suffix using that system : plain text c + + : class suffix { public : int origin_node ; int first_char_index ; int last_char_index ; suffix ( int node , int start , int stop ) ; int explicit ( ) ; int implicit ( ) ; void canonize ( ) ; } ; the suffix object defines the last character in a string by starting at a specific node , then following the string of characters in the input sequence pointed to by the first_char_index and last_char_index members. for example , in figure 8 , the longest suffix " abababc " would have an origin_node of 0 , a first_char_index of 0 , and a last_char_index of 6 . ukkonen 's algorithm requires that we work with these suffix definitions in canonical form. the canonize ( ) function is called to perform this transformation any time a suffix object is modified. the canonical representation of the suffix simply requires that the origin_node in the suffix object be the closest parent to the end point of the string. this means that the suffix string represented by the pair ( 0 , " abababc " ) , would be canonized by moving first to ( 1 , " ababc " ) , then ( 4 , " abc " ) , and finally ( 8 , " " ) . when a suffix string ends on an explicit node , the canonical representation will use an empty string to define the remaining characters in the string. an empty string is defined by setting first_char_index to be greater than last_char_index. when this is the case , we know that the suffix ends on an explicit node. if first_char_index is less than or equal to last_char_index , it means that the suffix string ends on an implicit node . given these data structure definitions , i think you will find the code in stree.cpp to be a straightforward implementation of the ukkonen algorithm. for additional clarity , use streed.cpp to dump copious debug information out at runtime . acknowledgments i was finally convinced to tackle suffix tree construction by reading jesper larsson 's paper for the 1996 ieee data compression conference. jesper was also kind enough to provide me with sample code and pointers to ukkonen 's paper . references e.m. mccreight. a space-economical suffix tree construction algorithm . journal of the acm , 23 : 262-272 , 1976 . e. ukkonen. on-line construction of suffix trees . algorithmica , 14 ( 3 ) : 249-260 , september 1995 . source code good news - this source code has been updated. it was originally published in 1996 , pre-standard , and needed just a few nips and tucks to work properly in today 's world. these new versions of the code should be pretty portable - the build properly with g + + 3.x , 4.x and visual c + + 2003 . stree2006.cpp a simple program that builds a suffix tree from an input string . streed2006.cpp the same program with much debugging code added . the original code is her for the curious , but should not be used : stree.cpp a simple program that builds a suffix tree from an input string . streed.cpp the same program with much debugging code added . 145 users commented in " fast string searching with suffix trees " follow-up comment rss or leave a trackback &nbsp on december 5th , 2006 at 3 : 01 am , martin said : nice paper but there is room for improvement . 1 ) do use the same example throughout the text instead of using different more or less suited examples to illustrate different points - thus making it hard to follow what is going on. mississippi would make a excellent example string . 2 ) figure 4 already contains an explicit update which is not explained before carrying on - that is rather confusing . &nbsp on december 5th , 2006 at 6 : 19 am , mark said : sigh , everyone 's a critic . i do n't know that this article will ever see a revision , but if it does , i shall keep your comments in mind . &nbsp on december 13th , 2006 at 5 : 45 pm , calin culianu said : your sample code fails to compile cleanly on newer compilers. i guess that 's because it was written back in 1996. at any rate thanks for taking the time to explain this. after reading your article i still do n't really understand it -- and i am not sure if that 's because i am too stupid your your article is n't clearly enough writte. * shrugs * &nbsp on december 13th , 2006 at 8 : 16 pm , mark said : hi calin , let me know what compiler you are using , i might take a try at updating the source . the big problem was that in 1996 there were n't any compilers that came anywhere near conforming to today 's standard , which was n't ratified until 1998 . as for understanding it , i agree that it 's hard - i wrote the article because i had such a hard time with it myself. i encourage you to try to work through some of the problems by hand , then see if you can duplicate the results with the debug version of the program and see if you get the same results . &nbsp on december 26th , 2006 at 3 : 00 pm , mark said : updated source code released , see the end of the article with the links ! &nbsp on february 20th , 2007 at 2 : 21 pm , samuel said : i 'd like to say thank you . this article and the source-code is definetly a big help in my diploma thesis where i need a suffix tree as a tool . &nbsp on february 20th , 2007 at 3 : 27 pm , mark said : thanks , samuel , nice to hear . &nbsp on february 21st , 2007 at 3 : 32 am , graham reeds said : i like your code - currently implementing the bwt algorithm with just rle as a preprocessor for xml transfer . a couple of points : * make a link to this article from the bwt one - you mention suffix trees help speed up bwt compilation , but i had to go searching and found this site from wikipedia . * lots of comments in the source - you tried doxygen which would make the comments more searchable . &nbsp on february 23rd , 2007 at 4 : 55 pm , tony said : hey mark , how can i use your code to tell me the index of a substring in a text ? &nbsp on february 25th , 2007 at 12 : 22 pm , mark said : tony , that 's kind of the whole point of the article , right ? use the code in walk_tree as an indication of how to navigate the tree . once you walk the tree , searching for a match to your text , you will end up at either a leaf or an interior node . if you are at leaf , you have found the only occurrence of the string , and can determine where it is by looking at the members of suffix . if you are at an interior node , you have found the root of a tree that will provide all the locations of the string in the text . good exercise to write this search routine ! &nbsp on february 27th , 2007 at 6 : 36 am , mark said : hi graham , believe it or not , when i wrote this article , doxygen did n't handle c code very well - mostly because it did n't exist yet ! i do n't spend too much time going back and fixing up old articles , mostly because of my belief in the inspiration words of samuel johnson : " no man but a blockhead ever wrote , except for money. " &nbsp on march 2nd , 2007 at 12 : 28 pm , shivam said : how can i find the position ( s ) of the search string ? ? what if there are wildcharacters in the pattern , can you recommend some references ? ? thanks &nbsp on march 2nd , 2007 at 1 : 23 pm , mark said : shivam , do you realize that string searching occupies at least one chapter in virtually every algorithms book ? a search on google for " string search algorithms " gets you 3.5 million hits . if you ca n't find some decent references on this , you are n't trying very hard . sorry to be harsh , but seriously , i can help you with specific problems related to the data compression on my site , but general questions that can be easily answered , well , you need to manage yourself . &nbsp on march 15th , 2007 at 11 : 02 pm , cariaso said : mark , while i agree with your sentiments for shivam , i ca n't resist pointing out : " string searching occupies at least one chapter in every single algorithms book is dedicated to string searching " if a book is dedicated to string searching , it seems a bit redundant to say that string searching occupies at least one chapter . this article was tremendously valuable a decade ago. since then there have been advances , especially coming from bioinformatics. anyone interested in the topic should investigate : an updated c implementation http : //www.icir.org/christian/libstree/ general notes http : //homepage.usask.ca/ ~ ctl271/857/suffix_tree.shtml big strings in small memory http : //csdl2.computer.org/persagen/dlabstoc.jsp ? resourcepath = /dl/trans/tk/&toc = comp/trans/tk/2005/01/k1toc.xml&doi = 10.1109/tkde.2005.3 a pairwise bioinformatics related tool http : //mummer.sourceforge.net/ a generalized bioinformatics tool http : //bibiserv.techfak.uni-bielefeld.de/mga/ &nbsp on march 17th , 2007 at 1 : 11 pm , mark said : thanks for the excellent links and comments michael ! as for the proofreading , well , that 's what comes of having no editor. i think i will violate the integrity of my blog comments by correcting it without leaving a trail . &nbsp on march 28th , 2007 at 1 : 40 am , eng-siong said : dear all , i found this , may be useful , its a standard template library for extra large data sets implemented by roman dementiev that support a multiple type of container . theres no suffix tree yet. : ( http : //stxxl.sourceforge.net/ eng siong &nbsp on april 11th , 2007 at 5 : 31 pm , diamante said : cool &nbsp on july 2nd , 2007 at 4 : 19 am , ha luong said : hi mark , i have read your article and i could n't understand the " active point " . the active point is the first non-leaf ? ( and i do n't know the first non-leaf ) . could you please show me what the active point is in your figure 6 ? thanks so much , ha luong &nbsp on july 2nd , 2007 at 6 : 55 am , mark said : ha luong , i think my wording in that paragraph is not as good as it could be . when i refer to the " first suffix that does n't terminate in a leaf node " , i am talking about the first suffix when considering the list of suffices : bookk ookk okk kk k which is the list of suffixes you are now attempting to insert into the tree. looking at figure 5 , you can see the suffix " k " terminates in the middle of the " kk " leaf node , which makes it the active point . if you do n't know what a non-leaf node is , you need to brush up on your data structures . &nbsp on july 12th , 2007 at 6 : 03 pm , david hou said : hi mark , thank you for the excellent paper. it saves me from esko ukkonen 's ( that one is sooo hard , german folks are too smart .... ) . i still do n't quite understand how the " end point " works , which is one crucial part of the whole thing. could you kindly provide a sample to explain it more detail ? thanks a lot . &nbsp on july 15th , 2007 at 7 : 31 am , mark said : when performing the insertion of a new string , the two most important points are the active point and the end point . the active point is discussed in the response above. when inserting a string into the tree , we look at the list of suffixes we are inserting. some of the suffixes will be added to the tree by simple addition of a new character on an existing leaf node. the first suffix that ca n't be added by this simple extension is used to mark the active point . i 'll go back to the process of adding bookke to figure 5 . first , bookke is added through simple extension of leaf node 1 . ookke is added through simple extension of leaf node 5 . okke is added through simple extension of leaf node 4 . kke is added through extension of leaf node 2 . at this point , the tree looks like the first part of figure 6. you can see that when we attempt to add " ke " to the tree , things are not so simple. there is no leaf node that terminates in " k " , so we ca n't just extend that leaf . the suffix " k " is part of the tree , but it is an implicit node that is in the middle of the " kke " branch terminating at node 2. ( part 1 of figure 6 ) . the active point of the tree is now that implicit " k " node on the node 2 branch. ( and that is where we will perform the split operation. ) once you enter into the split operation at the active node , you can walk through the pseudocode to see what the elusive endpoint is : if the implicit node 's next char is n't test_char { split the edge at the implicit node create new leaf edge starting at the split in the edge } else done = true ; the end point is the first node where you do n't have to perform a split as you add new suffixes . unfortunately i did n't include a good example showing this , so i need to add that to my to-do list . &nbsp on july 18th , 2007 at 11 : 18 am , david hou said : thank you mark , i feel much clear now and i am trying to implement it in c # , oh... it 's hard.. . also , i found another tuition introduces ukkonen 's suffix tree and there 's a demo is provide here : http : //www.csse.monash.edu.au/ ~ lloyd/tildealgds/tree/suffix/ # demoform , the interesting thing is , when i run same string on your code and their code , i got different result... ... and idea about it ? &nbsp on july 22nd , 2007 at 2 : 13 pm , mark said : well , if you could show me a short demo string that comes up with different results for the two programs , i 'd certainly be interested in seeing it ! &nbsp on july 23rd , 2007 at 7 : 30 pm , arao said : the book by prof. dan gusfield is a very good one on this . and esko ukkonen is a german ? ? i thought he was from finland.. . &nbsp on july 30th , 2007 at 3 : 19 pm , abhey shah said : on the mac i found i needed to recast t [ i ] into chars before printing , or it would just give me numbers . &nbsp on july 30th , 2007 at 5 : 15 pm , mark said : that seems kind of strange - t is typed as char. casting at as a char should have no effect. perhaps your compiler is using unsigned chars as default ? &nbsp on august 1st , 2007 at 9 : 45 am , abhey shah said : i tried gcc3.3 on linux as well as gcc4.0 on the mac , same thing , that was just doing g -lstdc streed2006.cpp . anyway , if anybody else runs into the same thing sed 's/streed2007.cpp &nbsp on august 1st , 2007 at 9 : 48 am , abhey shah said : and of course the command lines get f * * * ed : got to love web 2.0. anyway i 'm sure if anybody runs into the same thing they 'll be able to piece together the edit commands . &nbsp on august 27th , 2007 at 5 : 07 am , amit p said : i have been looking at the updated code and need to adapt it to take many different input strings and not just the one , i tried creating a loop for active and having each loop hold a different string however this has still not worked any ideas would be appreciated . thanks &nbsp on august 28th , 2007 at 11 : 18 am , amit p said : i added another line of input for t after addprefix loop , after the add input had the program recalculate n and added the for loop underneath , i will now try to write code that will input multiple strings from a loop. this did allow me to enter multiple strings into the same suffix tree . &nbsp on september 4th , 2007 at 7 : 13 am , adam said : i see that ibm 's many-eyes data visualization community just put up a new visualization type called a word tree ( visual suffix tree ) . http : //services.alphaworks.ibm.com/manyeyes/page/word_tree.html &nbsp on september 4th , 2007 at 7 : 49 am , mark said : that looks like a very nice visualization tool , it gives a nice understanding of how a suffix tree actually works . &nbsp on september 17th , 2007 at 4 : 01 pm , scott said : > > t [ i ] into chars before printing , or it > > would just give me numbers . > > that seems kind of strange - t is typed > as char. casting at as a char should > have no effect. perhaps your compiler is > using unsigned chars as default ? i noticed the same issue with visual c + + 2005. i believe the 'problem ' was that overload resolution was finding the operator int ( ) cast method in the aux class , and was using that to cast to int and thus calling operator &nbsp on september 17th , 2007 at 4 : 03 pm , scott said : yuck , my post got mangled due to embedded less-than characters. anyway , the overloaded int cast in the aux class was preventing the aux output method from being called . &nbsp on october 12th , 2007 at 2 : 33 am , till said : enter string : aa start end suf first last string 0 1 -1 0 1 aa would you like to validate the tree ? y suffix : aa comparing : aa to aa suffix 0 count wrong ! leaf count : 1 error ! branch count : 1 ok &nbsp on october 12th , 2007 at 9 : 19 am , mark said : @ till : i suspect this is a corner case for n = 2. you agree ? &nbsp on november 7th , 2007 at 2 : 19 am , rock linker said : hi mark appreciate for your sharing ! thank you so much ! btw : in your article , there is an conception " end point " , in your former response you also explained that , however , i still have some questions about that. according to your explaination , " end point " is the first node that need not to be splited , but you know , end point is shorter than the active point , and active point must be splited , how can an " end point " node exist in the suffix tree ? i am a little confused. thank you ! wait for your kindly response. thanks a lot ! &nbsp on november 7th , 2007 at 12 : 21 pm , mark said : if we order the suffixes of a string in decreasing length : rock ock ck k the active point will be the first of these suffixes which does not terminate on a leaf node . and like i said in the article , every suffix longer than the suffix at the active point terminates in a leaf. every suffix short than the suffix at the active point does not . as you are updating the suffix tree , you know you have reached the end point when an element in the suffix tree has the same descendant as the string you need to add at that point . i do n't know that there is a relationship between the end point and the active point. you seem to think there is some relationship between the end point and the active point , and i do n't think that is true . i suggest that in order to understand this , you just run through a few examples of moderate length to watch the active point , the end point , and the tree change in response to the addition of new suffixes . &nbsp on november 15th , 2007 at 1 : 53 am , bryan said : i still don ´ t understand the linear time thing . every time we add a new character we need to go through all the suffix pointers. that means that the time spent in every step depemds on how many suffix pointers are. and the number of suffix pointers is variable . if i am wrong , please explain me , because i don ´ t undertand . &nbsp on november 15th , 2007 at 7 : 07 am , mark said : @ bryan : hi bryan , the place where you are off base is here : > go through all the suffix pointers . if you look at either the pseudocode or the actual code , you 'll see that we do n't go through all the pointers , and that is what makes the algorithm efficient . when it comes time to insert a new character , we start work at the active point : plain text c + + : update ( new_suffix ) { current_suffix = active_point test_char = last_char in new_suffix done = false ; while ( ! done ) { if current_suffix ends at an explicit node { because we keep track of the active point , we know in advance where the next search is going to start , so we most definitely do not search through all the suffix pointers in order to insert a new suffix . try working through some insertions by hand and you 'll see how it works more clearly . &nbsp on november 21st , 2007 at 2 : 03 am , bryan said : hi mark : thank you for your soon reply. i ´ m going to try the insertions by hand. my doubt was more focused on how many times the while will be executed in the worst case. i ´ m going to check the article again and i hope i ´ ll get a better understanding of the algorithm . thank you for taking the time to read and reply . &nbsp on november 26th , 2007 at 6 : 47 pm , bryan said : hi mark : i ´ ve seen the light. at the end , the while has been executed as many times as branches are in the tree. and since the amount of branches is equal to the amount of leafs , the time remains linear . thank you for your time . bytes &nbsp on november 29th , 2007 at 11 : 03 am , tim rowe said : many thanks for the clearest explanation of the algorithm that i 've managed to find so far ! i 'm still struggling a little to understand it , but i think that 's because it 's genuinely tricky ( or i 'm genuinely thick ) rather than any problems with the explanation. off to try some examples on paper . &nbsp on november 30th , 2007 at 8 : 43 am , tim rowe said : what is the licensing situation on that code ? are we free to use it with acknowledgement in the code ? acknowledgement visible to the user ? apply to you for a licence ? &nbsp on december 1st , 2007 at 10 : 33 am , mark said : @ tim : see the link at the top of the page : liberal code use policy . but remember , this is demonstration code - you may be able to find something substantially more optimized elsewhere . &nbsp on december 14th , 2007 at 11 : 43 am , hlbnet said : i do not see how a suffix tree can be build in linear time ( so you understand i 'm not an expert ) . i know it is true ( read everywhere ) , but i definitively do n't understand how it is possible . if i follow your explanations , to construct our suffix tree , we have to browse all the characters of the text ( here is the o ( n ) i think ) and for each , we have to append the new character to all suffixes that are already in our tree. here , i see a loop on the already registered suffixes nested in the main loop on the characters. and the inner loop becomes bigger each time a new suffix is added . is there something magic somewhere that makes the whole algorithm finally linear ? &nbsp on december 14th , 2007 at 11 : 54 am , mark said : @ hlbnet : the reason the algorithm runs in linear time is that appending a new suffix to the tree can be done in constant time. the reason the suffix can be appended in constant time is because we keep track of the active point . if you look at the final version of the simplifed algorithm , you 'll see that there is an outer loop that iterates over all the characters in the input sequence. but there 's no inner loop. so the number of operations needed to create the whole tree is n * something , where something has an upper bound that is not dependent on n . &nbsp on december 17th , 2007 at 10 : 11 am , hlbnet said : i 'm not fully convinced just reading the algo , since i see a plain text c : while ( ! done ) in the plain text c : udpdate ( newsuffix ) function ( here is the inner loop ) . i see that there are several stop conditions in the loop , making it stop rather " quickly " . but it is still very hard for me to figure out the average number of loops that will be performed in a real example . i definitively need to think of it more in depth . thank you for your article and answers , it is very usefull for beginners like me ! &nbsp on february 14th , 2008 at 3 : 07 am , iena said : hi mark. . thanks on your article..a very big help for my thesis.. ; ) &nbsp on march 3rd , 2008 at 4 : 15 pm , fan said : hi mark , thank you for the good article . i have one question about how to update suffix tree , would you please give me some suggestions ? thank you very much . i have modified your source code in order to insert a new string to the suffix tree , update the suffix tree if new string does n't exist in the suffix tree. unfortunately , i was stuck on updating the suffix tree . here is an example , first inserts " hello " to the suffix tree which looks like : start end suf first last string 0 2 -1 1 4 ello 0 1 -1 0 4 hello 0 4 0 2 2 l 0 6 -1 4 4 o 4 3 -1 3 4 lo 4 5 -1 4 4 o then inserts " bok " to the suffix tree , first character 'b ' is added without any problem , start end suf first last string 0 2 -1 1 4 ello 0 1 -1 0 4 hello 0 4 0 2 2 l 0 6 -1 4 4 o 4 3 -1 3 4 lo 4 5 -1 4 4 o 0 7 -1 5 7 bok then 'o ' is being added to the suffix tree , it was found in the suffix tree , which indicates by start node 0 , end node 6. continuing on next character 'k ' , it first should append 'k ' to leaf node 'o ' and update its first and last character in the string from ( 4 , 4 ) to ( 6 , 7 ) , then creates a new edge to represent 'k ' and insert into the suffix tree. how should i modify the code on those steps ? the correct suffix tree should look like the following structure : start end suf first last string 0 2 -1 1 4 ello 0 1 -1 0 4 hello 0 4 0 2 2 l 0 6 -1 4 ( 6 ) 4 ( 7 ) ok 4 3 -1 3 4 lo 4 5 -1 4 4 o 0 7 -1 5 7 bok 0 8 -1 7 7 k &nbsp on march 4th , 2008 at 11 : 01 pm , mark nelson said : @ fan : well , i 'm not sure what you are doing makes any sense. if you already have " hello " in the tree , you ca n't have " bok " by itself , it has to be a suffix of some existing string in the tree. so when adding the " b " , you should have " hellob " in the tree . your modified algorithm does n't . so whatever you are trying to make is not really a suffix tree . = mark &nbsp on april 21st , 2008 at 6 : 54 pm , pt said : does any know of a good trie / suffix tree implementation in c # ? &nbsp on april 21st , 2008 at 8 : 39 pm , mark nelson said : @ pt : i 'd take a look at codeproject.com , and perhaps search krugle.com . &nbsp on april 23rd , 2008 at 1 : 29 am , sarba said : @ sarba hi mark , i want to modify your code to find all exact repeat positions of an input string .for example string s = ataggatagc .i want to find repeat ( here ata ) and there positions ( here 0,5 ) .can you give me any suggestion about how to modify the code ? &nbsp on april 23rd , 2008 at 7 : 46 am , mark nelson said : @ sabra : i 'm not sure i understand the question . &nbsp on april 24th , 2008 at 12 : 29 pm , sarba said : hi mark , thanks for your attention.ok forget the above question for time being . more simply can you explain me how can i find longest common substring of input string. suppose i have two string a. atatgcatcag b. gcatgcaccga i want to find longest common substring of the two sequences. what i did is as follow , i concatenate two string like this s = atatgcatcag # gcatgcaccga then made suffix tree .theoretically the edge from root node to the depth est internal node contains the longest common substring.so how can i find the depthest intenal node and its " edge level " from root . &nbsp on may 21st , 2008 at 4 : 24 am , prodvit said : hi mark. i read your article and i found it very useful. i 'm interesting in suffix trees for building a web search results clustering algorithm , like stc ( zamir et etzioni , 1998 ) . i 'm interested in understanding the difference between suffix trees and suffix arrays , in particular i would understand advantage in using one rather than other in clustering problems . can you help me ? thanks massimiliano &nbsp on may 21st , 2008 at 5 : 57 am , mark nelson said : @ prodvit : i wish i could give you a good answer here , but i do n't know a lot about suffix arrays - i need to get up to speed there myself. all i know for sure is that suffix trees are advertised as having good construction costs , and once constructed , should be just as useful as suffix trees . &nbsp on may 28th , 2008 at 3 : 24 am , void said : just wanted to let you know that i thought your article was good. clear and more understandable than alot of other articles on suffix trees i 've looked at . good work , thanks for sharing . &nbsp on may 28th , 2008 at 7 : 23 am , mark nelson said : @ void : thanks for the kind words. for some reason this is a tough algorithm to explain , to understand , and to illustrate. some day in the far off future i 'm going to take another crack at it and see if i can do better ! &nbsp on june 5th , 2008 at 4 : 34 am , giorgos said : hi mark , thanks for your article ! is it possible to decribe what happens with the string mississippi ? actually , i dont understand the step adding the missis suffix . i read the following link and its really confusing http : //www.allisons.org/ll/algds/tree/suffix/ &nbsp on june 5th , 2008 at 5 : 15 am , mark nelson said : @ girgos , if you 're having trouble with the description on the web site shown in your comment , why not ask the owner of that site for clarification ? &nbsp on june 5th , 2008 at 11 : 06 am , giorgos said : thanks for your quick response , mark ! i read your example with bookeeper , but when i tried to create the tree for mississippi , i had some problems . it would be great and you would help me a lot if you gave us a succinct example with the string mississippi too . thanks , giorgos &nbsp on june 16th , 2008 at 6 : 48 am , xyzzy said : hi , thanks for the nice article. it would be better if you add a few examples though , like how strees can be used for finding the longest common substring etc . &nbsp on june 16th , 2008 at 7 : 52 am , xyzzy said : ok. here 's one solution i found. when you find a character that 's already an implicit node , mark a $ under it so that the next character encountered will be added to this $ also . &nbsp on july 1st , 2008 at 3 : 38 pm , tamer said : hi , nice work. i am working on a research project that requires building a large suffix tree ( around 20k string , each with 4 to 8 letters ) . i worked on your code , and i guess the main problem is in the hash array. i mean if i can enlarge the hash array , i can store the large number of edges in the tree . could you please provide me with some way to change the hashing function so that to be able to generate a number between 0 and 20k or 30k . thanks , tamer &nbsp on december 5th , 2008 at 9 : 27 am , tonda said : hello , this si the best explanation of creating suffix tree i found so far ( however i still fully do n't understand it , maybe because i am not native english speaker ) . i have one question. i have 1mb file with characters representing part of dna. i need to find longest repeated substring ( lrs ) but these substrings can be over each other . example : bananas 1 ) lrs without overlapping : an or na 2 ) lrs with overlapping : ana i need to find the second one. but if i understand at least a little to suffix trees , they allow me to find only the first mentioned lrs. are n't they ? could you give me some direction , how to find the second one ? thank you . &nbsp on december 6th , 2008 at 1 : 54 pm , mark nelson said : @ tonda : to be honest , i do n't have a good answer for you. it looks like a tough problem . &nbsp on december 8th , 2008 at 7 : 03 am , pschloss said : thanks for your article and code. i was wondering whether you have developed a function to add strings to a pre-existing suffix tree to build a generalized suffix tree. i know you can just concatenate the strings together with unique separators , but this seems to run into problems when you have more than 256 strings and you would seem to generate and process some very long edges that are n't " real " . any suggestions ? this seems to get minimal mention in gusfield and other sources . &nbsp on january 30th , 2009 at 10 : 02 pm , links for 2009-01-30 « my weblog said : [ ... ] fast string searching with suffix trees ( tags : cs ) [ ... ] &nbsp on march 17th , 2009 at 1 : 52 pm , bbi5291 said : @ mark nelson : when you say that each new suffix can be appended in constant time , do n't you mean that adding a character to the end of a current suffix takes constant time ? it 's certainly not true that it is guaranteed to take constant time only to add a character to the tree as a whole. but it still takes linear time overall , right ? because whenever we do a lot of work for one character , it was due to not having done much during previous iterations. or you could say that the active point moves a linear number of times during the whole algorithm , and that each time it moves a constant amount of work is done , so the algorithm is linear overall . &nbsp on march 18th , 2009 at 6 : 38 am , mark nelson said : @ bbi5291 : yes , you are correct , when i say " each new suffix can be added in constant time " i am misusing the term suffix - what i actually mean is " each new character can be added in constant time " . but you are incorrect in thinking that adding a character to the tree is not constant time - only linear overall. adding a single character is definitely constant time only. the various operations that can occur each time a character is added do not change regardless of the length of the previously seen input. they do n't involve scanning back through the the tree. they are , in fact , constant , which is why the algorithm is guaranteed to run in linear time regardless of the input . we do n't do " a lot " of work for just one character. ( mostly because we maintain a suffix pointer at each node - this lets us navigate to the next smallest node with a single dereference. ) &nbsp on march 19th , 2009 at 12 : 06 pm , bbi5291 said : @ mark nelson : seems that we do agree on runtime complexities , then , we just misunderstood each other - yes , i understand that the operation of extending a single suffix by a single character is constant time . when i said " adding a character " what i meant was the process undertaken to transform the suffix tree of the first n characters to the one for the first n + 1 characters. here " a lot of work " can be done at once , but it 's still amortized constant , right ? now , one thing that bothers me is the canonicalization. this can require walking through a linear number of edges at once ; how do we know that this is amortized constant as well ? &nbsp on april 11th , 2009 at 5 : 09 pm , rodger87 said : hi i am working on common pattern searching algorithms. i was using suffix tree,but i was n't able to implement it for the search of common pattern without giving any input string . like , i have 15 sequences and i wanted to make suffix tree of each sequence and search for the common pattern in all the 15 sequences &nbsp on april 11th , 2009 at 6 : 26 pm , mark nelson said : @ rodger87 : sorry do n't really understand the question . from the problem you describe , you need to create and search 15 suffix trees . - mark &nbsp on april 16th , 2009 at 10 : 09 pm , rodger87 said : this is my algorithm : 1 set number of characters to be processed ws = 8000 ( note : we assume 8000 characters are processed at one time ) 2 compute length of longest common pattern ( overlap size ) . 3 for each sequence , si , in database do 4 set overlap string os to empty 5 while not end of sequence si do 6 set stmp = | os | + ws characters of si 7 construct a suffix tree , st , for the subsequence stmp 8 use multiple patterns search against the suffix tree st 9 record the search result 10 determine the content of overlap string os 11 update position for next ws characters from si 12 end while 13 end for i am not able to code it....in perl.. . &nbsp on april 18th , 2009 at 1 : 20 am , illya havsiyevych said : hello , i 've ported your source code to java http : //illya-keeplearning.blogspot.com/2009/04/suffix-trees-java-ukkonens-algorithm.html thanks for reference implementation , illya &nbsp on april 18th , 2009 at 6 : 53 am , mark nelson said : @ illya : thanks , that will be very helpful ! - mark &nbsp on may 16th , 2009 at 11 : 10 am , tagz | " fast string searching with suffix trees at mark nelson " | comments said : [ ... ] [ upmod ] [ downmod ] fast string searching with suffix trees at mark nelson ( marknelson.us ) 0 points posted 10 months , 1 week ago by jeethu tags search suffix algorithm [ ... ] &nbsp on may 16th , 2009 at 2 : 51 pm , zubair said : hi mark , thnx for writing such a beautiful article. i m working on building a " weighted suffix tree " for particular application. therefore i have to modify the whole algorithm of developing the suffix tree and its search algorithm. wht i believe is some minor changes in the current code and intelligent guidance will lead me to a better solution. i have already implemented the prototype for my work but the efficiency of the implementation in term of processing is quite low. i would like for your coordination or help in ma work . i need to update the suffix tree for a certain period of time by giving new strings to tree. if a particular suffix exists all it need to do ....... ( lets assume nothing to do ) . if new suffix arrives it have to update the tree on run time ....... thats only the part of problem . hope u can guide me regarding this as i m still a student : ) . further more if ask for a personal contact with you regarding ma work : ) ..... . &nbsp on may 19th , 2009 at 5 : 51 am , mark nelson said : @ zubair : sorry i wo n't be able to give you personal guidance on this , perhaps you could contact others who have posted here . &nbsp on may 24th , 2009 at 2 : 53 pm , illya havsiyevych said : mark , fyi refactored java code with some pictures and test runs . http : //illya-keeplearning.blogspot.com/2009/05/suffix-trees-refactored-java-code.html main ideas : - reuse java hash map ; - better oop . thanks , illya &nbsp on june 8th , 2009 at 1 : 16 am , illya havsiyevych said : fyi , suffix trees java applet - build and visualize your tree . http : //illya-keeplearning.blogspot.com/2009/06/suffix-trees-java-applet.html thanks , illya &nbsp on june 13th , 2009 at 11 : 59 am , maria said : hi mark , i am trying to understanding how the construction of a suffix tree works. i have tried to continue the construction of the tree for bananas starting with the steps on figure.3 , but i have a problem : as a next step in fig.3 i want to build a tree for bana , and i think i just need to add an 'a ' to the three edges of the tree for ban ( i do n't add another edge ) . so , my tree for bana will have again three edges ( no further branching ) starting from the root and having as strings bana , ana , and na. my problem is that i am not sure what happens with the suffix 'a'. it does not appear ( in what i have done ) explicitly on a separate edge. if we had a suffix trie we would have an edge for 'a'. now in the suffix tree we have an implicite node , which implicitely separates 'n ' and 'a ' of the edge 'na'. my question is : if i query for 'a ' , will the system " take into account " this implicit node between 'n ' and 'a ' , and thus see the 'a ' ? should i think about this in this way ? i may be have trouble with what " implicit " mean . the same problem is with the tree for bookk on figure 5. i do n't understand why we do n't have an edge for the suffix 'k ' ( the smallest suffix of bookk , apart from the empty one ) . if what i have written above for the identification ( matching ) of the suffix 'a ' is correct , then 'k ' will be " identified " on one of the edges having 'kk ' as a string or substring. will it be the edge 'kk ' ( the one between nodes 0 and 2 ) ? or may be on the edge 'bookk ' ( the one between nodes 0 and 1 ) ? thanks a lot in advance . &nbsp on june 13th , 2009 at 4 : 24 pm , mark nelson said : @ maria : check out ilya 's java app and you can see the results of construction in real time. that might be helpful . &nbsp on june 15th , 2009 at 12 : 35 pm , xutao said : hi mark , good article and useful code. however when i walk_tree for " banana $ " , it took 2816 iterations ! it is certainly nowhere near linear. please help &nbsp on june 15th , 2009 at 3 : 00 pm , xutao said : the following code is to help query the tree with a string. if the query is a substring of a suffix , it will return the position substring . example code following tree construction [ c ] int start , end ; search_tree ( q , start , end ) ; cout = strlen ( query ) ) { cout &nbsp on june 15th , 2009 at 3 : 01 pm , xutao said : plain text c : / * input a string to search query [ ] output start_index and end_index on the string ( tree ) search against * / void search_tree ( char query [ ] , int & start_index , int & end_index ) { int start_node = 0 ; int qp = 0 ; //query position start_index = - 1 ; end_index = - 1 ; bool stop = false ; while ( ! stop ) { edge edge = edge : : find ( start_node , query [ qp ] ) ; if ( edge. start_node = = - 1 ) { stop = true ; break ; } if ( start_node = = 0 ) start_index = edge. first_char_index ; print_edge ( edge ) ; for ( int i = edge. first_char_index ; i < = edge. last_char_index ; i + + ) { if ( ( query ) ) { //cout < < " whole query matched " < < endl ; stop = true ; break ; } else if ( query [ qp ] = = t [ i ] ) { //cout < < query [ qp ] < < " " ; qp + + ; end_index = i ; } else { //cout < < " partially matched " < < endl ; stop = true ; break ; } } if ( ! stop ) { //proceed with next node start_node = edge. end_node ; if ( start_node = = - 1 ) stop = true ; cout < < " next node " < < start_node ; } } } &nbsp on july 3rd , 2009 at 3 : 47 pm , illya havsiyevych said : hello , fyi , some other suffix trees based java applets : * generalized suffix tree - http : //illya-keeplearning.blogspot.com/2009/06/generalized-suffix-trees-java-applet.html * diff - http : //illya-keeplearning.blogspot.com/2009/07/suffix-trees-based-diff-java-applet.html thanks , illya &nbsp on november 25th , 2009 at 1 : 39 pm , legistrate said : i found your implementation the most useful of the various implementations out there , but the divergence from gusfield was very confusing at first. then there are also some things that gusfield does n't seem to address directly . for example , if you just wanted to implement suffix links , how would you know what the characters are when you walk up one edge to arrive at the parent ( y in the text ) . you need to know more than just the one character leading from that parent to the edge so you can walk back down after you traverse the suffix link with possibly multiple nodes . i ask because in your code i finally realized that you do n't actually walk down the edge to either a newly created inner node or to new children. in this way you have the suffix start track the position of the char that indicated the edge to the correct node. while i 'm still fuzzy on why exactly that works , in general i would say it does . the start being larger than stop signals an external node , and the converse an internal node. so in a phase , that means extensions are applied rule 1 , rule 2 ( splits ) , rule 2 ( new kids ) , rule 3. but when i use the string " mississippi $ " i have an unexpected split in the last phase. in phase 10 adding ( the last ) 'i ' suffix start is 9. the active point splits ppi $ into p : pi $ and i $ , and the active point moves to the root. thus start is incremented by one ( 10 ) and the next extension should be explicit ( start = = stop ) which it is since 'i ' is already an internal node off the root. rule 3 breaks the loop and we move to the next phase ( ' $ ' ) . but here , the stop has increased too , and now the algorithm thinks that the active point should be an implicit node. this is not true , so a split is performed on the explicit node , and there is now an extra empty child in the final tree . could you maybe mention a little of how you devised a way to have a start counter for tracking the relevant index in the string as you move from extension to extension rather than the for loop covering each extension ? &nbsp on november 25th , 2009 at 4 : 06 pm , legistrate said : hmm , well it looks like i made an implementation mistake. the algorithm does correctly handle my phase 11 ( ' $ ' ) . i am still unsure of how you discovered the proper way to track the position of the active extension , but as the code works , i guess i could read through it a few more times. i do however thing that the suffix pointers added are not always necessary ( ie extras ) , but that could be a mistake too : p . &nbsp on december 9th , 2009 at 8 : 31 pm , its entirely true » c # suffix tree said : [ ... ] i was unable to find a c # implementation of the suffix tree so i ported one i found at mark nelson ’ s blog. the project of the c # port is located here [ ... ] &nbsp on february 10th , 2010 at 5 : 12 am , ziman said : thanks much for this overview , it definitely helped me much to get an a at today 's exam ! : ) &nbsp on february 16th , 2010 at 12 : 13 pm , suffix tree resources « kcodel said : [ ... ] http : //marknelson.us/1996/08/01/suffix-trees/ [ ... ] &nbsp on march 5th , 2010 at 4 : 54 am , ayan_2587 said : hello. . i have a small doubt here. . i did not understand the " canonize " function here.. why are we using it and what is exactly its role over here. . please help ! ! ! &nbsp on november 19th , 2010 at 5 : 58 pm , cparker7 said : i have a c # implementation based on your documentation and source code. i have implemented findall ( ) based on your comments : from point at which match is found , traverse subtree , and each leaf indicates a match. there is a bit of computation which must be done based on the path from root to leaf. i have that all working . there is a bug which i can not figure out. there are certain trees which generate only n leaf nodes , where there are n + 1 actual matches. the simplest test case i can generate is the string " anasan " , and the query string " a " . the tree that i am generating looks like : ( 1-5 : 'nasan ' ) = > 1 ( 3-5 : 'san ' ) = > 4 ( 1-5 : 'nasan ' ) = > 2 ( 3-5 : 'san ' ) = > 5 where each link has the template : ( { first } - { last } : 'string ' ) = > { node } when searching for 'a ' , we find the edge from 0-3 , and then traverse to all the leaves . thoughts ? &nbsp on december 5th , 2010 at 7 : 00 pm , mark nelson said : @ cparker7 : i 'm not sure i follow your notation , but it does n't appear that you have created a valid suffix tree. for starters , you should have a leaf for character 'n ' , the smallest suffix . each edge in the tree has a parent and a child node , and a string on the edge. so we could represent the suffix tree in figure 2 like this : 0-1 : bananas 0-2 : a 0-3 : na 0-4 : s 2-5 : na 2-6 : s 3-7 : s 3-8 : nas 5-9 : nas 5-10 : s use that notation to describe your tree and let 's see what it looks like . - mark - mark &nbsp on december 17th , 2010 at 5 : 12 pm , bla said : this code that you shared here is a really bad design and poor implementation . &nbsp on march 17th , 2011 at 9 : 01 am , tueken said : after reading and thinking for quite a while , i start to understand how the algorithms works , especially the concept of " active point " . your explanation is great. thanks a lot . &nbsp on april 2nd , 2011 at 1 : 50 am , whitebomb said : everyone 's a critic , cool ~ &nbsp on april 5th , 2011 at 5 : 13 pm , xplode said : two more steps to the fastest string search algorithm .. . &nbsp on april 17th , 2011 at 2 : 12 am , whitebomb said : hi mark ! i want to use vector to store all the edges , since i insist on using hash table is extremely difficult for me ( may be some guys ) to remove edges . what 's your point on using vector and hash table ? please tell me about their efficiency or convenience . thank you ! waiting for your kindly reply . &nbsp on april 18th , 2011 at 5 : 12 am , mark nelson said : @ whitebomb : look into the suffix array data structure : http : //en.wikipedia.org/wiki/suffix_array &nbsp on may 1st , 2011 at 11 : 39 am , pravesh parekh said : well this is the first time that i am looking at a suffix tree and i must say that it was a nice and refreshing to look at your page. the diagram clearly made me understand how to represent a suffix tree followed by edge compression. i do not need the coding of this so i have n't gone into the complex issues that you later brought up but i am pretty sure that they would be great as well. one thing that you could include here is how the tree was made : the removing one letter and traversal. all good otherwise. cheers ! &nbsp on august 16th , 2011 at 8 : 46 pm , rayan yousif said : hi mark , really i 'd like to thank you for all that you 've offer ,i have been interested in searching algorithms , and i 'm looking for a new or an improved algorithm for large strings indexing ( string of tera-bytes ) , can you advice me to any ? does suffix tree suitable more ? thank you again . . &nbsp on august 17th , 2011 at 8 : 07 am , mark nelson said : @ rayan : a suffix tree is normally an in-memory structure , so if you are indexing terabytes , you might run into issues of memory exhaustion . - mark &nbsp on august 29th , 2011 at 3 : 49 pm , ivan said : i find it a bit confusing when you stated " any node that we create as a leaf will never be given a descendant " . in figure 6-1 , the node '2 ' is later added two descendant '6 and '7 ' in figure 6-3. i guess you may argue that the node 6 in figure 6-3 is actually the previous node '2 ' , but would n't it be better if you use the same number for the nodes ? to better illustrate , see here : https : //skitch.com/iveney/fw3ci/fast-string-searching-with-suffix-trees &nbsp on august 29th , 2011 at 4 : 10 pm , mark nelson said : @ ivan : i agree - that is not explained clearly . when i am speaking of a leaf node , i identify it by the suffix that terminates at that node - not the number. the number is a convenience used in some places , but the suffix is what is important . in the picture you identified , the node with number 2 corresponds to suffix kke. after the construction process , kke is still a leaf node , but the edge was split , so there is a new interior node. that node has number 2 , which is obviously a confusing point . - mark &nbsp on august 31st , 2011 at 9 : 20 am , suffix tree : an illustration of the algorithm « use you imagination said : [ ... ] and found ukkonen ’ s linear time online algorithm quite hard to understand. mark nelson has a good article about this , however , in my opinion the writing is not so great and some part is [ ... ] &nbsp on october 20th , 2011 at 2 : 35 pm , burrow wheeler transform , suffix arrays and fm index « homologus said : [ ... ] version of constructing suffix trees was presented in a paper by edward mccreight in 1976. i found this link most helpful on suffix [ ... ] &nbsp on november 29th , 2011 at 1 : 29 pm , tony bruguier said : mark , thanks for writing this article. it 's quite helpful. i think i understand almost everything , except one sentence. you say : " knowing how the construction algorithm works , you can see that if you find a certain character as a descendant of a particular suffix , you are bound to also find it as a descendant of every smaller suffix. " how can we guarantee this ? thanks tony ( different from another tony above ) &nbsp on december 1st , 2011 at 11 : 35 am , mark nelson said : the sentence i have given describes an invariant property of the suffix tree. if you find that character 'd ' is a descendant of 'abc ' , it means that the tree * must * also contain bcd and cd. if this was not the case , it would n't be a suffix tree . the algorithm must be written to guarantee this invariant holds . " how " is what the article is all about ! - mark &nbsp on december 13th , 2011 at 2 : 47 pm , garret wilson said : mark , i can not express how invaluable this article has been to me in implementing a syntax tree. i needed a java syntax tree implementation , and after days of wrestling with tutorials ( mostly yours ) , i am starting to wrap my head around it. i am by no means an algorithm expert , but after the mental sweat i 've poured into this , i 've come away with a few insights that make your algorithm a bit clearer for me. please do n't take any of these thoughts negatively---they merely reflect how my mind has come to understand the algorithm . the suffix class was a little confusing from its name , as it represents a suffix from the root , yet there is some optional " leftover " part past the active node. in my implementation i called this class state following ukkonen . the suffix/state and edge end offsets you use are inclusive. in 2011 , in my mind anyway , many programmers are accustomed to end positions being exclusive , and indeed it makes many of the length calculations cleaner and more intuitive . several equivalent variables were arbitrarily intermingled , and logic could have been further refactored and isolated. for example , in edge : : splitedge ( ) the new near edge is created extending from suffix.origin_node---which should always be equivalent to the old edge 's edge.start_node. using the suffix origin node when splitting an edge obscures the fact that edge-splitting logically is an operation completely independent of suffixes. that is , to split an edge i merely need to provide the edge to split and a length position at which to split ( even though this length may have originally come from the suffix ) . this loosens the coupling of edge-splitting logic from the overall suffix-tree building operation , making the isolated routine more understandable and testable on its own . again , these observations are less criticisms of your approach than awe that i was able to understand this at all , thanks mainly to reading your article. i have finished my java implementation. after tidying up the code and added methods to make the class useful in actual string processing , i 'll post a link here. thanks again for publishing this . &nbsp on december 13th , 2011 at 3 : 03 pm , mark nelson said : @ garret : no worries , as the years go by i always see plenty of room for improvement , and i would really like to rewrite this article someday. i finally did a rewrite of an lzw article after over 20 years , and i was happy with that - maybe this one is next ! thanks for your comments , i hope they help others trying to work through this stuff . - mark &nbsp on december 15th , 2011 at 1 : 50 pm , garret wilson said : ( in my comment above , i of course meant " suffix tree " instead of " syntax tree " . ) i have posted an overview of suffix trees and their application , along with links to my implementation in java : http : //www.garretwilson.com/blog/2011/12/15/suffix-trees-java.xhtml i referenced your article. thanks again . garret &nbsp on january 4th , 2012 at 11 : 24 pm , jason young said : mark , thank you for the code and kind explanation . i think i ca n't fully understand the concept of the suffix tree. . in your code , what is the role of origin_node of suffix ? thank you . jason . &nbsp on january 18th , 2012 at 12 : 32 am , sergey makarenko said : mark , thanks for a great article . i believe that in streed2006.cpp signature of plain text c : ostream &amp ; operator&lt ; &lt ; ( ostream &amp ; s , aux const&amp ; a ) should include const for the second parameter. otherwise numbers are outputted instead of characters. ( at least for ms visual studio 2010 ) . &nbsp on january 29th , 2012 at 12 : 38 am , suffix tree « demonstrate 的 blog said : [ ... ] suffix tree ， 但 是 没 见 到 后 文 了 。 网 上 能 找 到 的 一 些 实 现 如 比 较 早 的 ， c 的 版 本 感 觉 局 限 性 比 较 大 （ libstree 与 这 个 ） ， 有 两 个 c + + [ ... ] &nbsp on april 20th , 2012 at 2 : 39 am , to do or learn | pearltrees said : [ ... ] even you can make a tree mccreight 's original algorithm for constructing a suffix tree had a few disadvantages. principle among them was the requirement that the tree be built in reverse order , meaning characters were added from the end of the input. this ruled the algorithm out for on line processing , making it much more difficult to use for applications such as data compression. in fact , the reduction in the number of nodes is such that the time and space requirements for constructing a suffix tree are reduced from o ( n 2 ) to o ( n ) . in the worst case , a suffix tree can be built with a maximum of 2n nodes , where n is the length of the input text. fast string searching with suffix trees [ ... ] &nbsp on may 23rd , 2012 at 4 : 50 am , can someone please explain ukkonen 's suffix tree algorithm in plain english ? | php developer resource said : [ ... ] excessive use of mathematical symbology. the closest to a good explanation that i ’ ve found is http : //marknelson.us/1996/08/01/suffix-trees/ , but he glosses over various points and some aspects of the algorithm remain [ ... ] &nbsp on july 24th , 2012 at 12 : 37 pm , eateshkandpal said : hi mark , this was a very helpful explanation about suffix trees i have already gone through it twice. i wonder if few comments could be marked which too add up to the article for eg. the one explaining 'active points' . &nbsp on august 5th , 2012 at 3 : 56 am , random ( ) » blog archive » suffix trees , suffix arrays and ukkonen ’ s algorithm said : [ ... ] mark nelsons c + + implementation [ ... ] &nbsp on october 15th , 2012 at 12 : 39 am , sush said : can you please explain , how can the suffix tree be used to find all the unique substrings of a string ? i have many strings and my task is to find unique substrings of all those strings and then take their union. thus , finally i need to find all the unique substrings in the given set of strings. can this whole task be implemented using suffix trees efficiently ( in terms of time ) ? if yes , can you please explain the algorithm for that ? i have searched the net , but i did n't find any good solution for my problem. that 's the reason i am asking here . i am waiting for a kind and detailed reply . thanks &nbsp on october 15th , 2012 at 12 : 45 am , sush said : i forgot to mention , it would be really nice if you rewrite the article and the source codes as they are around 6 years old ! thanks . &nbsp on october 15th , 2012 at 6 : 14 am , mark nelson said : actually , it is 16 years old , and yes , it certainly could use a an update . i do n't think a suffix tree is the structure you need to find all the unique substrings in a given string. it does n't have that information . - mark &nbsp on october 16th , 2012 at 12 : 45 am , sush said : so , can you please suggest a data structure for my problem with your experience ? i thought of using trie but , my single string 's length can go upto 2000. so , trie would not be space efficient . what i am thinking about is , to use the suffix tree to find the prefixes of all suffixes ( which are itself the substrings ) . ca n't this be done by traversing the from root to leaf and taking all the prefixes of that suffix ? the time complexity would be o ( n ^ 2 ) . so far , i have read that no algorithm can give substrings of a string in less than o ( n ^ 2 ) time. so , would n't it be feasible to do it with suffix trees ? &nbsp on october 16th , 2012 at 6 : 27 am , mark nelson said : if you want to generate all the substrings of string s , i would suggest that you do so using a simple algorithm that walks through the string and stores all the substrings it finds in a set. this below needs cleanup , it is just giving you the idea : plain text c : for ( i = 1 to s. size ( ) - 1 ) for ( j = 1 to s. size ( ) - 1 ) { string sub = s. substr ( i,j ) ; results. insert ( sub ) ; } } &nbsp on october 16th , 2012 at 10 : 39 am , sush said : as i told you earlier , i need an o ( n ^ 2 ) algorithm but what you are suggesting is o ( n ^ 2lgn ) . apart from this , i have m number of strings. so , for finding unique substrings for all of them even using the best algorithm of o ( n ^ 2 ) would take overall o ( n ^ 2 * m ) time. thus , i am just thinking about creating a generic suffix tree and then doing it in much lesser time. but for that i need to know what is the way to process all unique substrings from a given string 's suffix tree. and that 's what i am asking you . the algorithm you told is almost like brute force and is known to me . please provide any ideas for solving my problem using suffix trees . thanks . &nbsp on october 16th , 2012 at 1 : 49 pm , mark nelson said : @ sush and as i told you earlier , i do n't think that a suffix tree is going to do you any good . the algorithm i gave you will operate in o ( n ^ 2 ) under normal circumstances - it uses an unordered_set to store the substrings. unordered_set is a hashed container , so insertions will normally take place in constant time. any hashed container obviously has much worse behavior in the worst case , but that 's usually not what we care about. it would be very hard to construct a pathological case . it seems that somehow you have decided that both the suffix tree construction algorithm and i are responsible for solving your problem. i assure you that neither of us is . - mark &nbsp on october 16th , 2012 at 2 : 26 pm , sush said : okay . thanks for the kind info. i am trying to code in c. so , can you please tell me that is there any container like unsorted_set in c ? or some other replacement for it ? &nbsp on october 16th , 2012 at 2 : 29 pm , mark nelson said : not in the c standard library . i 'm sure you can find many different container libraries to choose from. however , for this project , the complexity of what you are trying to do is going to be fairly larger in c than in c + + , java , or another language with built-in containers . - mark &nbsp on october 17th , 2012 at 2 : 21 am , sush said : yes ! thinking about the same , i am planning to code it in c + + . so far , i know that there is a set in c + + which inserts in o ( lgn ) . can you just point out if there is some other container which inserts in o ( 1 ) in c + + ? or will i need to get some library in c + + also ? and one more point which is bugging me is that , in your code you have used " s.substr ( i,j ) " . lets say k = j-i. thus length of the substring is k. so , would n't it take o ( k ) time to extract the substring out of the original string ( or even copying the substring to some other string and then using it ) ? so , is there a way in c + + to do it in constant time ? if this step is done in constant time and we have some container in c + + which inserts in constant time , then your whole algorithm will do it in o ( n ^ 2 ) time . i know your blog is to provide suffix tree implementation and not to solve my problem but it would be really kind of you if you just answer these questions . thanks . &nbsp on october 17th , 2012 at 5 : 11 am , mark nelson said : > container which inserts in o ( 1 ) in c + + ? c + + 98 introduced the set container to the standard library. usually based on a red-black tree , it offers lg ( n ) performance for most types of access . tr1 added unordered_set , which is a hashed container. it has been supported in most compilers for quite some time. depending on which version of the compiler you are using , it may be in the std : : tr1 namespace , or in the std namespace. by design , it has constant insertion and lookup times except for pathological conditions . there are all sorts of string operations that are o ( n ) where n is the length of the string. mostly people do n't care too much about this because strings are usually short. so there is little incentive to optimize . if you are dealing with some huge computational burden imposed by string operations , you might want to subclass std : : string and create your own methods. but the times when this is necessary will be very rare . - mark &nbsp on october 17th , 2012 at 10 : 02 am , sush said : thanks a lot mark. i got a lot of help from you. i know this is a blog but are there other means to contact you ( via email or something ) ? i would really like to show the problems i face in future , so that if you wish you can help me with your experience . &nbsp on october 18th , 2012 at 7 : 02 am , sush said : just fyi , i got the solution for my problem. it will be solved by using trie. i will add all the strings to the trie and then get the unique substrings . &nbsp on december 14th , 2012 at 10 : 08 am , algorithm of the year 1973 & project euler 26 « john ruddy said : [ ... ] i had a relatively large set of strings generated. i used mark nelsons implementation of the suffix tree in c # in order to complete this. by generating a suffix tree for each of the strings i managed to build [ ... ] &nbsp on january 22nd , 2013 at 2 : 35 pm , hh said : thank you very much for this great post. i wish more people would be capable of explaining algorithms in such an understandable way. kind of reminded me of the sleator/tarjan splay tree ( not the data structure , but the transparency of the explanation ) . i had much fun implementing this in the scala programming language : https : //github.com/sciss/contextsnake/tree/v0.0.1 it 's still quite close to your c + + code , so not exactly functional style , but in the next refactoring step it will be more 'scalaish'. like garret , i used exclusive stop indices which make things a bit cleaner , and there are a few redundant things that can be omitted . ( next step will be implementing a probabilistic estimator of the next character of a given suffix. any ideas how to add this to the existing structure ? i will need to efficiently look up all the outgoing next characters of an explicit node. perhaps just a hash-map of that node 's index. ) &nbsp on march 12th , 2013 at 3 : 18 am , ukkonen ’ s suffix tree algorithm in plain english ? | everyday i 'm coding said : [ ... ] use of mathematical symbology. the closest to a good explanation that i ’ ve found is fast string searching with suffix trees , but he glosses over various points and some aspects of the algorithm remain [ ... ] &nbsp on march 15th , 2013 at 11 : 01 am , suffix tree simple explaination | simple2013 said : [ ... ] http : //marknelson.us/1996/08/01/suffix-trees/ [ ... ] &nbsp on april 25th , 2013 at 12 : 09 pm , azal said : hi there , thank you so much for writing this comprehensive article ! i am working on a problem where , given a string of length n , i need to calculate the occurrence counts of all the " consecutive " substrings of length of m = 1..n . for instance if the string is 0 0 1 0 1 1 then i would need to calculate the number of times i see : 0 1 00 , 01,10,11 001,010 , 101,011 0010,0101,1011 00101,01011 001011 so one approach would be to construct the tree in o ( n ) and then search for each pattern of length m in o ( m ) . however , since there are n-m + 1 patterns for each m , and m ranges from 1..n the overall computational complexity would be quite high ! ( i believe i can probably do better if i construct a suffix array from the suffix tree , to use for subsequent search ) . but my main question is this : in a 2005 power-point presentation titled " suffix tree and suffix array techniques for pattern analysis in strings " ( which can be found here : http : //www.cs.helsinki.fi/u/ukkonen/erice2005.ppt ) ukkonen mentions " thm : suffix tree tree ( t ) gives complete occurrence counts of all substrings motifs of t in o ( n ) time , ( although t mauve o ( n ^ 2 ) substrings ! ) " but he 's left no reference. i was wondering if this follows directly from the construction algorithm described here , i.e. during construction ( of the tree ) one can simultaneously obtain/update the counts . i 'd appreciate any input/insight on this . thanks ! &nbsp on april 25th , 2013 at 12 : 23 pm , mark nelson said : i 'm not familiar with that reference , you might try going directly to ukkonen . - mark &nbsp on april 25th , 2013 at 3 : 24 pm , azal said : thanks for getting back to me so quickly : ) i just wanted to make sure that it 's not like the stree ( as construced here ) happens to somehow contain the occurrence counts well , with no additional processing . but that does n't seem to be the case anyway . thanks again . &nbsp on april 26th , 2013 at 3 : 29 am , victor liang said : hi mark , thanks for your great work. but i have a place confused in your code streed2006.cpp . in the function addprefix ( suffix &active , int last_char_index ) , there is a line about adding new edge , edge * new_edge = new edge ( last_char_index , t.n , parent_node ) . my question is why the new edge is defined starting from last_char_index to the t.n ? in my understanding , last_char_index is the character i am reading from the beginning of the input string , t.n seems the end position of the input string. why should i insert the entire string at first ? why the insertion process is not done by adding one character step by step incrementally ? thanks . &nbsp on june 1st , 2013 at 4 : 32 pm , ukkonens suffix tree algorithm in plain english ? - tech forum network said : [ ... ] excessive use of mathematical symbology. the closest to a good explanation that i ’ ve found is fast string searching with suffix trees , but he glosses over various points and some aspects of the algorithm remain [ ... ] &nbsp on november 7th , 2013 at 3 : 02 pm , ukkonen ’ s suffix tree algorithm in plain english ? | ask programming & technology said : [ ... ] excessive use of mathematical symbology. the closest to a good explanation that i ’ ve found is fast string searching with suffix trees , but he glosses over various points and some aspects of the algorithm remain [ ... ] leave a reply you can insert source code in your comment without fear of too much mangling by tagging it to use the ig : syntax hiliter plugin. a typical usage of this plugin will look like this : [ c ] int main ( ) { printf ( " hello , world ! \ n " ) ; return 1 ; } [ /c ] note that tags are enclosed in square brackets , not angle brackets. tags currently supported by this plugin are : as ( actionscript ) , asp , c , cpp , csharp , css , delphi , html , java , js , mysql , perl , python , ruby , smarty , sql , vb , vbnet , xml , code ( generic ) . if you post your comment and you are n't happy with the way it looks , i will do everything i can to edit it to your satisfaction. username ( * required ) email address ( * private ) website ( * optional ) links from google wordpress popular posts plugin v2.1.4 [ w ] [ weekly ] [ regular ] popular posts fast string searching with suffix trees lzw data compression c + 11 - threading made easy dns service discovery on windows hash functions for c + + unordered containers c + + algorithms : next_permutation ( ) arithmetic coding + statistical modeling = data compression the random compression challenge turns ten 20 heads in a row - what are the odds ? data compression with the burrows-wheeler transform zlib - looking the gift code in the mouth lzw revisited end wordpress popular posts plugin v2.1.4 recent comments ernst in the random compression challenge tu … ernst in the random compression challenge tu … dimitrisv in c + + generic programming meets oop - … dont in automating putty mark nelson in automating putty dont in automating putty ernst in the random compression challenge tu … ernst in zlib - looking the gift code in the … mark nelson in the random compression challenge tu … ooms in the random compression challenge tu … feeds main feed main comment feed this article 's comment feed categories security cisco windows programming voip standards hackery humor networking serial communications video puzzles scams linux culture graphics uncategorized work writing audio snarkiness mathematics web articles people business c/c + + programming complaining computer science magazine articles data compression recent entries c + + generic programming meets oop – std : : is_base_of debugging windows services startup problems my big company code interview one definition to rule them all how i spent my last few weeks the random compression challenge turns ten c + 11 – threading made easy c + + 11 : range-based for and auto visual studio 11 and modern c + + my books the data compression book serial communications : a c + + developer 's guide , 1st. ed . serial communications : a c + + developer 's guide , 2nd ed . c + + programmer 's guide to the standard template library developing cisco ip phone services : a cisco avvid solution archives select month july 2014 ( 1 ) april 2014 ( 1 ) march 2014 ( 2 ) november 2012 ( 1 ) october 2012 ( 1 ) june 2012 ( 1 ) may 2012 ( 1 ) april 2012 ( 1 ) march 2012 ( 1 ) february 2012 ( 3 ) january 2012 ( 2 ) december 2011 ( 3 ) november 2011 ( 2 ) october 2011 ( 1 ) september 2011 ( 2 ) august 2011 ( 1 ) july 2011 ( 2 ) june 2011 ( 2 ) april 2011 ( 2 ) february 2011 ( 3 ) january 2011 ( 2 ) december 2010 ( 1 ) november 2010 ( 2 ) october 2010 ( 3 ) september 2010 ( 1 ) august 2010 ( 5 ) july 2008 ( 1 ) june 2008 ( 1 ) may 2008 ( 1 ) april 2008 ( 1 ) march 2008 ( 1 ) february 2008 ( 1 ) january 2008 ( 1 ) december 2007 ( 2 ) november 2007 ( 5 ) september 2007 ( 1 ) august 2007 ( 3 ) july 2007 ( 4 ) may 2007 ( 1 ) april 2007 ( 1 ) november 2006 ( 2 ) october 2006 ( 2 ) september 2006 ( 5 ) august 2006 ( 6 ) july 2006 ( 6 ) june 2006 ( 9 ) october 2005 ( 1 ) february 2004 ( 1 ) october 2002 ( 1 ) august 2002 ( 1 ) july 2002 ( 3 ) april 2002 ( 1 ) march 2002 ( 1 ) january 2002 ( 1 ) september 2001 ( 1 ) june 2000 ( 1 ) january 2000 ( 1 ) march 1998 ( 1 ) december 1997 ( 1 ) september 1997 ( 1 ) january 1997 ( 1 ) september 1996 ( 1 ) august 1996 ( 1 ) april 1996 ( 1 ) january 1996 ( 1 ) may 1992 ( 1 ) april 1991 ( 1 ) february 1991 ( 1 ) may 1990 ( 1 ) february 1990 ( 1 ) october 1989 ( 1 ) addthis button begin © 1996 mark nelson powered by wordpress | talian designed by va4business , virtual assistance for business who 's blog can be found at steve arun 's virtual marketing blog
