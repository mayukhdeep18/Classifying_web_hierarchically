--------- tetrahedral sphere left aligned -------- --------- tetrahedral sphere right aligned ------- www.neubert.net - dr. neubert 's website the entropy reduction laboratory the flashsort algorithm --------- introduction ------------ the problem of in-situ sorting with minimal auxiliary space in minimal time. introduction in " mathematical analysis of algorithms " , ( information processing '71 , north holland publ.'72 ) donald knuth remarked " ... that research on computional complexity is an interesting way to sharpen our tools for more routine problems we face from day to day. " with respect to the sorting problem , knuth points out , that time effective in-situ permutation is inherently connected with the problem of finding the cycle leaders , and in-situ permutations could easily be performed in o ( n ) time if we would be allowed to manipulate n extra " tag " bits specifying how much of the permutation has been carried out at any time. without such tag bits , he concludes " it seems reasonable to conjecture that every algorithm will require for in-situ permutation at least n log n steps on the average " . now this conjecture is shown not to be valid. a new efficient way to find cycle leaders is presented and in-situ permutations can be performed in optimal time. the algorithm flashsort sorts in o ( n ) time without the manipulation of n extra " tag " bits. here an auxiliary vector of only length m is required , where m is a small fraction of the number of elements n . --------- introduction to the flashsort algorithm ------------ classification accumulation run the loops : - find cycle leader - in situ permutation short range sorting the flashsort algorithm flashsort sorts n elements in o ( n ) time. flash-sort uses a vector l ( k ) of length m in a first step for the classification of the elements of array a . then , in a second step , the resulting counts are accumulated and the l ( k ) point to the class boundaries. then the elements are sorted by in situ permutation. during the permutation , the l ( k ) are decremented by a unit step at each new placement of an element of class k in the array a . a crucial aspect of flashsort is that for identifying new cycle leaders. a cycle ends , if the the vector l ( k ) points to the position of an element below the classboundary of class k . the new cycle leader is the element situated in the lowest position complying to the complimentary condition , i.e. for which l ( k ) points to a position with evidently , in addition to the array a of length n which holds the n elements to be sorted , the only auxiliary vector is the l ( k ) -vector. the size of this vector is equal to the number m of classes which is small compared to n , e.g. m typically may be set to m = 0.1 n in case of floating point numbers. finally,a small number of partially distinguishable elements are sorted locally within their classes either by recursion or by a simple conventional sort algorithm. --------- detailed desription ------------ in these papers you find a more detailed description of the algorithm . karl-dietrich neubert the flashsort algorithm this is an ms 6.0 word document as published in the proceedings of the euroforth'97 -conference , oxford , england,sept.26-28 1997 karl-dietrich neubert , flashsort1 algorithm in dr. dobb 's journal feb.1998,p.123 click here to subscribe to ddj ------ demonstrations ------------ a collection of flashsort demos for animations of the flashsort principle and runtime , select collection of flashsort demos ------ goto collection of flashsort codes ------------ a collection of flashsort codes for codes in various languages and various modifications of the flashsort algorithm see collection of flashsort codes . --------- general version ------------ ------------------------- comment -------- < tr > < td width = 0 bgrcolor = lightgrey > < font face = arial > < b > general < br > version < /b > < /font > < /td > < td bgcolor = lightgrey > < h3 > the more general version of flashsort < /h3 > < p > for real life applications , a recursive version of flash-sort is available. with that version , within the limits of available memory , any number of strings of any length and any number of keys with independent selectable collation sequences for any sort order of columns may be sorted in optimal run time. as an example , sorting on a 133 mhz pc 100 000 strings of 50 bytes length with a 50 byte key takes about 4.6 sec , sorting 1000 000 strings of the same length and same number of keys requires 46 sec. < /td > < /tr > --------------------------------------------------- end of comment - --------- back ------------ back to go back to the welcome page click here . this page and each part of it copyright Â© 1998 karl-dietrich neubert . all rights reserved design by vladimir marek . last update of the page : march 18 , 2003
