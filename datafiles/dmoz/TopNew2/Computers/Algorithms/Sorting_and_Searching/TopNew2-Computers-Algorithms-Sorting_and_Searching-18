home page versi ó n espa ñ ola home of.. . the three dimensional bubble sort algorithm art or science ? i discovered this curious but probably completely useless algorithm in the fall of 1999. i even sent off a note to dr. dobb 's journal about it , and was delightfully surprised when they wrote back some months later and suggested i do an article for them. i was too busy at the time , and the world lost an opportunity for an incremental increase in useless knowledge. i am presenting this now ; my gift to the world and perhaps my only legacy. who knows maybe some mathematician working away in some dusty office may find it a keystone to solving some obscure theory . the concept.. . the idea is very simple. start with a screen populated with coloured pixels , randomly distributed. the number of possible colours does n't matter , but it makes a more interesting image in the end if fewer colours are used. then we begin sorting the pixels according to the following algorithm : loop for a screen of dimensions w , h pick a pixel at random coordinates x , y where x = { 0 thru w - 1 ) } , y = { 0 thru ( h - 2 ) } if amount of red in pixel below ( at x , y + 1 ) is greater than red in current pixel , swap pixels pick another pixel at random coordinates x , y where x = { 0 thru ( w - 2 ) } , y = { 0 thru ( h - 2 ) } if amount of green in pixel to the lower right ( at x + 1 , y + 1 ) is less than green in current pixel , swap pixels pick another pixel at random coordinates x , y where x = { 1 thru ( w - 1 ) } , y = { 0 thru ( h - 2 ) } if amount of blue in pixel to the lower left ( at x-1 , y + 1 ) is less than blue in current pixel , swap pixels if ( ! done ) goto loop we continue looping like this millions of times , until an equilibrium becomes established in which colours are sorted into pools. the pixels of pure colour within the pools become immobile , and the only action that continues after that is some interplay along the interfaces of the colour pools . as a generalized way of examining this phenomenon , imagine a given pixel with a determined amount of red , green , and blue. depending on it 's red content , it experiences a force moving it up or down the screen , and depending on the amount of each of the other two colours , it experiences forces moving it diagonally left and right. it 's final resting position is the vector sum of these three forces , in relation to all the other pixels on the screen. this sorting algorithm can be taken to even higher dimensions , and can be applied to any combination of properties , not just the colours of pixels. however , in any scenario i can imagine , conventional sorting techniques are far simpler and faster. if you find some use for this algorithm beyond creating psychedelic images , please let me know and please at least credit me for the idea . 3dsort.exe for the pc - winzipped ( 26.6 kb ) is my latest windows ' gdi version ( 16 feb 2004 ) , which does the sort on various surface shapes ( square , round , torus , etc. ) in < 2 minutes for an area 512 pixel squared , and just seconds for an area 256 pixels squared. optimized in assembler , it probably does n't get any faster than this - at least on a p4 - 2 ghz platform , anyhow . here are some images produced by it : circle.gif , triangle.gif , torus.gif . some more images.. . sort based on rgb , sort based on rgb , sort based on ycrcb , sort based on ycrcb . .. . update may 2005 3dsortex.exe for the pc - winzipped ( 17.1 kb ) is my latest demo of a special effect. it illustrates a sort based on a special palette of 15 hues of each of the colours : red , green , blue , magenta , cyan , and yellow , for a total of 90 colours. it seems that since in any of the colours only a maximum of two of the three primaries red , green , or blue are used , it allows a complete sort to take place ie : at the end all pixels have found a stable location , not like in the above where pixels at the interfaces on some of the colour pools never find a stable position . not only do we get a stable sort , but if sorted on a circle , we end up with a smooth spectrum. the colours form pie shaped wedges around the circle forming a classic colour wheel running through the rainbow. in final analyses , however , how this could be of any use alludes me . since the human eye can not distinguish among all the hues of each colour , i have added an old animation trick - palette animation - to demonstrate that indeed the colours have sorted in perfect spectral order. after doing a sort in the provided application 3dsortex , hit " toggle rotations " and you will see a colourful , rapidly rotating , " beach ball " . this is only possible because the colours have been sorted in spectral order around the circle. each colour in the image is assigned a palette index , and by rotating the colours of the palette and re-applying them on each frame , it appears as if the whole image is rotating. here is the code i wrote to create the colour palette . .. . below is a graph that illustrates progress during the sort for various numbers of colours on a square 512 pixels on a side. it can take almost 200 million iterations to reach a steady state. my first versions years ago took over two hours to do the sort. only with today 's p4 processors and hand-optimized assembler code can the sort be now done in a couple of minutes instead of hours. it can be seen that number of colours does n't make a lot of difference as to when the algorithm reaches a steady state , where the colours are sorted as much as they can be . the only dramatic difference is that with more colours , more pixels are left to forever wander along the interfaces without a home to call their own . the colours were derived by stepping each red , green , and blue colour component by 128 , 64 , 32 , 16 , or 8 , then removing the black , white , and grays from the resultant colours for purely aesthetic reasons. this yields 25 , 123 , 727 , 4,911 , and 35,935 colours respectively . -back-
