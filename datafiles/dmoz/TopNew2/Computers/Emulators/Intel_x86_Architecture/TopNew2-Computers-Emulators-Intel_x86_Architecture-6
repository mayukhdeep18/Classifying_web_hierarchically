1 overview the bochs virtual pc consists of many pieces of hardware. at a bare minimum there are always a cpu , a pit ( programmable interval timer ) , a pic ( programmable interrupt controller ) , a dma controller , some memory ( this includes both ram and bios roms ) , a video card ( usually vga ) , a keyboard port ( also handles the mouse ) , an rtc with battery backed nvram , and some extra motherboard circuitry . there might also be a ne2k ethernet card , a pci controller , a sound blaster 16 , an ide controller ( + harddisks/cdrom ) , a scsi controller ( + harddisks ) , a floppy controller , an apic . . there may also be more than one cpu . most of these pieces of hardware have their own c + + class - and if bochs is configured to have more than one piece of a type of hardware , each will have its own object . the pieces of hardware communicates over a couple of buses with each other - some of the things that the buses carry are reads and writes in memory space , reads and writes in i/o space , interrupt requests , interrupt acknowledges , dma requests , dma acknowledges , and nmi request/acknowledge. how that is simulated is explained later fixme . other important pieces of the puzzle are : the options object ( reads/writes configuration files , can be written to and queried while bochs is running ) and the gui object. there are many different but compatible implementations of the gui object , depending on whether you compile for x ( unix/linux ) , win32 , macintosh ( two versions : one for mac os x and one for older os 's ) , beos , amiga , etc . and then there is the supporting cast : debugger , config menu , panic handler , disassembler , tracer , instrumentation . 2 weird macros and other mysteries bochs has many macros with inscrutable names. one might even go as far as to say that bochs is macro infested . some of them are gross speed hacks , to cover up the slow speed that c + + causes. others paper over differences between the simulated pc configurations . many of the macros exhibit the same problem as c + + does : too much stuff happens behind the programmer 's back. more explicitness would be a big win . 2.1 static methods hack c + + methods have an invisible parameter called the this pointer - otherwise the method would n't know which object to operate on. in many cases in bochs , there will only ever be one object - so this flexibility is unnecessary. there is a hack that can be enabled by # defining bx_use_cpu_smf to 1 in config.h that makes most methods static , which means they have a " special relationship " with the class they are declared in but apart from that are normal c functions with no hidden parameters. of course they still need access to the internals of an object , so the single object of their class has a globally visible name that these functions use. it is all hidden with macros . declaration of a class , from iodev/pic.h : .. . # if bx_use_pic_smf # define bx_pic_smf static # define bx_pic_this bx_pic . # else # define bx_pic_smf # define bx_pic_this this- > # endif .. . class bx_pic_c : public logfunctions { public : bx_pic_c ( void ) ; ~ bx_pic_c ( void ) ; bx_pic_smf void init ( bx_devices_c * ) ; bx_pic_smf void lower_irq ( unsigned irq_no ) ; bx_pic_smf void raise_irq ( unsigned irq_no ) ; .. . } ; extern bx_pic_c bx_pic ; and iodev/pic.cc : .. . bx_pic_c bx_pic ; # if bx_use_pic_smf # define this ( &bx_pic ) # endif .. . void bx_pic_c : : lower_irq ( unsigned irq_no ) { if ( ( irq_no < = 7 ) && ( bx_pic_this s.master_pic.irq_line [ irq_no ] ) ) { bx_debug ( ( " irq line % d now low " , ( unsigned ) irq_no ) ) ; bx_pic_this s.master_pic.irq_line [ irq_no ] = 0 ; bx_pic_this s.master_pic.irr & = ~ ( 1 < < irq_no ) ; if ( ( bx_pic_this s.master_pic.irr & ~ bx_pic_this s.master_pic.imr ) = = 0 ) { bx_set_intr ( 0 ) ; bx_pic_this s.master_pic.int = 0 ; } } .. . } } .. . ugly , is n't it ? if we use static methods , methods prefixed with bx_pic_smf are declared static and references to fields inside the object , which are prefixed with bx_pic_this , will use the globally visible object , bx_pic . if we do n't use static methods , bx_pic_smf evaluates to nothing and bx_pic_this becomes this- some classes use bx_smf , others have their own version of the macro , like bx_pic_smf above . 2.2 cpu and memory objects in up/smp configurations the cpu class is a special case of the above : if bochs is simulating a uni- processor machine then there is obviously only one bx_cpu_c object and the static methods trick can be used. if , on the other hand , bochs is simulating an smp machine then we ca n't use the trick. the same seems to be true for memory : for some reason , we have a memory object for each cpu object. this might become relevant for numa machines , but they are not all that common -- and even the existing ia-32 numa machines bend over backwards to hide that fact : it should only be visible in slightly worse timing for non-local memory and non-local peripherals. other than that , the memory map and device map presented to each cpu will be identical . in a up configuration , the cpu object is declared as bx_cpu . in an smp configuration it will be an array of pointers to cpu objects ( bx_cpu_array [ ] ) . for memory that would be bx_mem and bx_mem_array [ ] , respectively . each cpu object contains a pointer to its associated memory object . access of a cpu object often goes through the bx_cpu ( x ) macro , which either ignores the parameter and evaluates to &bx_cpu , or evaluates to bx_cpu_array [ n ] , so the result will always be a pointer . the same goes for bx_mem ( x ) . if static methods are used then bx_cpu_this_ptr evaluates to . ugly , is n't it ? 2.3 bx_debug/bx_info/bx_error/bx_panic -- logging macros go through a generic tracing mechanism. can be switched individually on/off. might eat a lot of cpu time - i think there are some bx_info calls for each instruction executed . 2.4 bx_tick1 , bx_tickn ( n ) , bx_tick1_if_single_processor bx_tick1_if_single_processor , only used in cpu.cc -- and only confuses the matter. it calls bx_tick1 on a single-processor and nothing on smp . 3 check_max_instructions ( count ) - only needed on smp configurations without debugger support. i am going to change the cpu emulation a lot ( hopefully cleaning it up in the process ) , so i 've decided to lose every smp thing that gets in the way for me. this is one of them. later , when up works faster and better , i fully intend to restore smp functionality -- or work with somebody else who does . 3.1 bx_sim_id when using cosimulation it has something to do with which simulator that is executing ? in any case , i removed it from my own source tree . 3.2 bx_hrq , bx_raise_hlda , bx_intr , bx_set_intr ( b ) , bx_iac ( ) 3.3 various macros associated with dynamic translation relics of kevin lawton 's initial attempts of using dynamic translation to ia-32 machine code instead of interpretive emulation. that development continued in plex86 , which seems to be more or less abandoned for the moment . bochs will probably go in the direction of dynamic translation at some point in the future but for we will concentrate on better guis , better configuration , better hardware emulation and better support for reverse engineering. we would also very much like bochs to be faster but we will use simpler methods for the foreseeable future. these relics will be cut out as soon as possible . 3.4 cosimulation support for debugging changes in the cpu emulation , especially really big optimizations , kevin lawton invented something he called " cosimulation " . the idea is to run two different cpu emulators in lock-step and constantly compare their cpu state. the idea is very good -- and has been independently discovered by many people for decades -- but is hard to put into practice. as kevin lawton wrote in some early docs : fixme : something about every time he uses cosimulation he has to hack on the code to make it work . i think the prudent thing would be to remove it for the time being -- and hack in specific hooks the next time somebody wants to use it. it should be maintained as a separate patch until we have found a cleaner way of doing it . 4 memory - an introduction both ram and bios'es. bioses can be loaded individually. physical_read ( ) , physical_write ( ) . all address translation and access checking has already taken place in the cpu . some hardware interaction takes place through this object : vga. this is unfortunately hardcoded into the memory object at the moment : ( 5 the basic cpu simple cpu : no caches ! does have tlbs. some real ia-32 implementations distinguish between tlbs for code and for data -- we do n't. we save some time on having 1024 tlb entries , which is a lot more than almost all real cpus have at the moment. different cpu levels -- level 5 is not complete , yet . 5.1 some of the things we have to emulate - the ia-32 real mode. protected mode. 16-bit code , 32-bit code. segments , tlb , instruction prefetch queue , writes to memory can be executed " immediately " ( makes things a bit harder for us later on ) , extraordinarily complex and varied instruction formats. four different privilege levels , and then a system management mode on top of that for some of the cpus. six different segment registers ( four on < 386 ) , capable of overriding the default segment register for the instruction , usually ds , but sometimes ss. prefixes , address and operand size changes , tons of flags , tons of special cases about which registers can be used for what purpose. totally free alignment of both code and data. instructions can be one to sixteen bytes. io privilege level , io privilege map , v86 mode . yada yada , you get the picture.. . 5.2 some example instructions ( real mode , intel syntax ) inc ax mov cx , [ 23 + bx ] ( protected mode , 32-bit default size , at&t syntax ) < something with two size prefixes , a 0x0f prefix , a lock prefix ? and a complicated address. lock add [ bx * 4 + cx * 2 + dx + 1234 ] , 17 ? > 5.3 decoding instructions is * hard * on nicer processors , decoding instructions is an easy task. it 's especially nice on the mips and the alpha . on ia-32 it 's just about as lousy as it can get : / in order to reduce the complexity a bit , all the decoding of the operand fields is done first , by bx_cpu_c : : fetchdecode ( ) , and then the instruction is executed by one of many hundred small methods that do n't have to care ( much ) about their operands . 5.4 bxinstruction_t b1 mod r/m rep_used imm8 , imm16 , imm32 jmp .. . execute resolvemodrm16 resolvemodrm32 5.5 the main loop - first cut 5.6 the main loop - interrupts/traps/exceptions 5.7 the main loop - smp 5.8 " prefetching " should be called something else . 5.9 fetchdecode 5.10 execute pointers 5.11 the anatomy of memory accesses segments , segment caches , base + limit , type 5.12 the main loop - interrupts/exceptions/traps 5.13 so how was the prefetching in detail again ? prefetch revalidate_prefetch_q invalidate_prefetch_q when is it invalidated ? when is it revalidated ? when do we actually have to do any of these ? 5.14 things i lied about a20 , extend down segments , fpu , synchronization between cpu and ( potentially external ) fpu. reset of the cpu by forcing a triple-fault . debugger interface , config interface temporary disabling of interrupts ( after ss changes ) ; ; might have to go below the following section 5.15 flag handling lazy flags , 5 32-bit ints to describe the operation. some macros that evaluate the flags on demand . 5.16 how are exceptions implemented ? all instructions restartable from the register state + bxinstruction_t . commit eip + esp ( why that ? ) after successful execution of the whole instruction . never possible to generate exception /after/ changing the visible state . longjmp ( ) , setjmp ( ) 5.17 what if we trip on an assertion ? lots of checks all over the place. also deep inside routines called by the cpu main loop. die/cont/alwayscont/quit in control panel - or a debugger. how does it do that ? some variation on the exception scheme ? 6 specific tricks 6.1 4gb in real mode what is the trick and how does bochs make sure that it works 6.2 switching from protected mode to real mode reset + cmos 6.3 typical reset thru keyboard controller 6.4 triple-fault reset 6.5 fast reset gate 6.6 a20 change should probably hitch a ride on the tlb paging mechanism for speed . 6.7 " cmos " nmi gate 6.8 v86 6.9 v86 with virtual interrupt flag 6.10 apic : irq rerouting to nmi 6.11 smp : ipi ( inter-processor interrupt ) 6.12 smp : cache bounces 6.13 smp : locked read-modify-writes 6.14 smp : spinlocks 6.15 smp : tsc potentially out of synch 6.16 smp : bios and necessary tables 6.17 smm - system management mode not implemented yet. required for acpi , i think . 6.18 huge amounts of memory do n't want bochs to push out other programs - handle swapping manually . bios and memory size reporting pae small window - big memory file only need to swap in/out when tlb changes keep memory on 4k boundary and use mmap ( ) needs > ia-32 machine ( e.g. alpha or some other 64-bit behemoth ) or lfs . 6.19 pnp 6.20 pci - configuration 6.21 pci controller 7 things that make you go " hmmm " .. . 7.1 16k pages between 0xc0000 and 0xfffff with pci 7.2 why read_rmw_virtual_ ( byte | word | dword ) ? 8 optimization ideas 8.1 traces " almost all programming can be viewed as an exercise in caching " -- terje mathisen resolve16/32 ca n't be cached like this ( example that uses registers to generate an effective address ) 8.2 squish out flags handling bx_need_flags , bx_sets_flags 8.3 how to be lazy with addresses 8.4 handle repeating instructions in bigger globs special versions of access_linear ( ) 8.5 split access_linear into read and write versions 8.6 combine segment limits with tlb pages a bit that says if everything is ok or the address has to be reevaluated 8.7 better branch prediction for execute ptr calls switch ( len ) { case 7 : i [ len-7 ] .execute ( i [ len-7 ] ) ; case 6 : i [ len-6 ] .execute ( i [ len-6 ] ) ; .. . case 0 : i [ len-0 ] .execute ( i [ len-0 ] ) ; } 9 communication between devices 9.1 ticks and hardware emulation the non-cpu hardware in the bochs virtual pc needs to run some code once in a while to either do some real work , synchronize with the rest of the machine or interact with the host os . timers , based on simulated instructions retired count. the gui is made like this too -- that is probably a bad idea. bx_tick1_if_single_processor ( ) examples of worker functions : xxxxx . 9.2 interrupts 9.3 dma holda 9.4 irq pins isa irq2/9 , irq3 , irq4 , irq5 , irq6 , irq7 , irq.. . pci inta , intb , intc , intd - routing i pci controller + on motherboard . 9.5 interrupt routing level/edge triggered . pic apic pci controller 9.6 nmi 10 communication between vga and gui 10.1 idle ( hlt ) and gui 10.2 gui and configuration 10.2.1 floppy disk /dev/fd0 a : < path to disk file > inserted/ejected icon click - > set_status ( inserted/injected ) how to check with ioctl 10.2.2 cd rom /dev/cdrom disk change how does el torito work ? only in bios ? what about hardware atapi ? 11 various hardware 11.1 cpu 11.2 cpu - smp 11.3 apic 11.4 pit 11.5 pic - master/slave 11.6 slowdown 11.7 realtime pic 11.8 rtc + cmos 11.9 fpu fwait , exception handling , something about a weird exception + an irq reserved for the fpu . 11.10 memory some of the address range is handled by the i440 pci chipset , which may subdivide it further . 11.11 i440 pci chipset also handles shadow roms . 11.12 agp 11.13 dma address bus sizes ? built into pci chipset ? speed ? limited to isa bus speed ? -- no. dma happens as fast as devices want , provided the cpu allows it . 11.14 floppy controller 11.15 ide 11.16 harddisk 11.17 cdrom 11.18 speaker 11.19 sound blaster 11.20 ne2k nic 11.21 mouse 11.22 keyboard 11.23 parallel port 11.24 serial port 11.25 usb 11.26 scsi 11.27 irq in general 11.28 ordinary bios 11.29 vga bios 11.30 lbe both some bios calls and some " hardware " 12 how to register a new device 13 how to make snapshots 14 how to suspend/resume 15 how to make configurations easier # ! ... . bochs --help bochs -h bochs --version // also prints compile options bochs -v ( version ) bochs < config filename > bochs -v // tells us which config file is used + all the options read from // it . 16 dreams for the future : suspend/resume - without apm ( for debugging/wizards ) . suspend/resume - with apm . automatic floppy disk change detect . automatic cdrom disk change detect . check that longjmp ( ) /setjmp ( ) does n't violate c/c + + rules about which variables are valid after a jump . net bridge gtk + /gnome gui setup wizard debugger interface in ctvision better mouse + keyboard handling - copy vmware with xgrabkey/xgrabmouse obviate the need for a client program to handle the mouse + keyboard linux console api for the screen easily run on real svga hardware , with only a thin debug/log layer in between likewise for other hardware - tell bochs what i/o , irq , dma , mem resources the hardware uses , let it negotiate with linux to access and lock it. might need a suid proxy. svga is a special case : ) good term mode ( bochs in curses - emulate mda ? cga ? ) bidirectional parallel port - some api as linux 2.4 and vmware good idle handling in all guis use shared memory , so many bochs instances will share a pool of memory cut'n'paste between host and guest gnu lightning jit'ing port gnu lightning to alpha use xft/render so copying vga fonts wo n't be necessary anymore compressed harddisks and undo logs/checkpoints t æ nk hvis vores disk i/o ender med at blive hurtigere end vmwares ; ) autodetect hvilken mus og antal knapper og den slags /much/ better error messages ! midi support joystick support - w/mouse , analog joystick , digital joystick , etc. as input . usb - access to real usb net usb - proxy the mouse + printer to bochs ' usb net ? usb - debugger/monitor usb - tun/tap like interface to user provided simulated hardware decide on good and consistent configuration strategy : use cmos or configuration file . 17 error messages check that floppy/cdrom/disk are accessible with the current privileges and give the poor user some sensible error messages if not , including examples of commands to fix the problem ( s ) . with bigmem support : check that 1 ) glibc supports lfs , 2 ) that the kernel supports it , 3 ) that the file system supports it , 4 ) that there is room enough in the designated directory . 18 tools/links nasm - also contains ndisasm , a nice disassembler for 8086 real mode and 386 protected mode. http : //nasm.sourceforge.net/ bcc - bruce 's c compiler , by bruce evans. generates either 8086 real mode code or 386 protected mode code. used to compile the bioses . as86 - assembler for 8086 real mode code , by bruce evans. version xxx - older versions do n't accept the -o ( optimize forward jumps ) flag. it is not quite intel syntax ( and very far from at&t syntax ) . usually included with ld86 in a package called bin86. built into cygwin ( fixme : true ? ) ld86 - linker for 8086 real mode code , by bruce evans. see as86 . pc timing faq , by kris heidenstrom - his home page is at http : //home.clear.net.nz/pages/kheidens/ and has many interesting docs. here 's the link to the faq : ftp : //ftp.simtel.net/pub/simtelnet/msdos/info/pctim003.zip serial port faq release 19 , by christian blum : http : //www.repairfaq.org/filipg/link/ports/f_the_serial_port.html there are other versions floating around on the net but this was the newest i could find. it 's in html whereas the original i read so many years ago was a nice , single plain text file. if somebody finds a link to that version i 'd like to know .
